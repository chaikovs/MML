<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of grep</title>
  <meta name="keywords" content="grep">
  <meta name="description" content="GREP">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">applications</a> &gt; <a href="index.html">common</a> &gt; grep.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for applications/common&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>grep
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>GREP</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function	[pout,p]=grep(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> GREP
      a unix-like, very fast utility to find patterns
      in any files in folders and their subfolders

 SYNTAX
      help
             GREP        show this screen
             GREP -p    show extended help for PATTERN/FILE
             GREP -f    show contents of output structure P
             GREP -e    show examples
      search
             GREP PATTERN FILE(*)
             GREP OPT1 ... OPTn PATTERN FILE(*)
        [FL,P] = GREP(PATTERN,FILE(*))
        [FL,P] = GREP({PATTERN(s)},{FILE1(*),...,FILEn(*)})
        [FL,P] = GREP(OPT1,...,OPTn,PATTERN,FILE)
        [FL,P] = GREP(OPT1,...,OPTn,{PATTERN(s)},{FILE1(*),...,FILEn(*)})

 OPT    : arg    processing
 ---------------------------------------------------------------------------------
 -c    :    prints only a count of the lines that contain the pattern(s)
 -D    :    debug mode: shows major processing steps
 -d    :    debug mode: shows all   processing steps
 -da    :    debug mode: shows all   output including debug messages
 -e    :  PL    searches for a string in pattern-list PL or {PL1,...,PLn}
    : {PL}    useful syntax when the string contains an option flag character (-)
           multiple instances of &lt;-e PL&gt; and/or &lt;-e {PL,...}&gt; may be listed
       PL       searches for the first token in pattern without white spaces
      {PL}       searches for complete pattern(s) including white spaces
 -f    :  PF    takes the list of patterns from ASCII pattern-file PF
           each line defines a single pattern that may include white spaces
 -i    :    ignores upper/lower case distinction during comparisons
 -I?    :  IL    only includes folders/files with at least one matching pattern
      {IL}       from IL or {IL1,...ILn}, which may include regular expressions
           multple instances of &lt;-I? IL&gt; and/or &lt;I? {IL,...}&gt; may be listed
   -Id    :    searches for inclusions in folders
   -If    :    searches for inclusions in file names
   -Ip    :    searches for inclusions in full paths: folder/filename
 -l    :    prints the names of files with matching lines once
 -n    :    precedes each line by its line number in the file
 -Q    :    does not prefix output with file name
 -R    :    uses the regular expression engine &lt;regexp&gt; [def: &lt;strfind&gt;]
 -r    :    recursively searches in subfolder(s)
 -s    :    works silently and displays only error messages
 -u    :    does not produce underlined text
 -V    :    prints name of each file before it is searched
 -v    :    prints all lines except those that contain the pattern
 -x    :    prints only lines that are matched entirely
 -X?    :  XL    excludes folders/files with at least one matching pattern
      {XL}       from XL or {XL1,...XLn}, which may include regular expressions
           multple instances of &lt;-X? XL&gt; and/or &lt;X? {XL,...}&gt; may be listed
   -Xd    :    searches for exclusions in folders
   -Xf    :    searches for exclusions in file names
   -Xp    :    searches for exclusions in full paths: folder/filename

 NOTES        all folder separators are replaced by unix-style &lt;/&gt; to facilitate
           the use of regular expressions with &lt;-I?|X?&gt; options
        &lt;-I?|X?&gt; options allow wildcard searches using regular expressions
        clicking on underlined text opens the file at the matching line</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="grep.html" class="code" title="function	[pout,p]=grep(varargin)">grep</a>	GREP</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="grep.html" class="code" title="function	[pout,p]=grep(varargin)">grep</a>	GREP</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function	p=ehelp(p,fnam,tag)</a></li><li><a href="#_sub2" class="code">function	p=ini_par(ver,tim)</a></li><li><a href="#_sub3" class="code">function	[p,msg]=set_opt(otbl,p,varargin)</a></li><li><a href="#_sub4" class="code">function	p=get_folders(p)</a></li><li><a href="#_sub5" class="code">function	p=get_folder(p,frot,crot,depth,ix)</a></li><li><a href="#_sub6" class="code">function	p=get_files(p)</a></li><li><a href="#_sub7" class="code">function	p=get_file(p)</a></li><li><a href="#_sub8" class="code">function	[tf,p]=chk_path(mode,p,fnam,frot)</a></li><li><a href="#_sub9" class="code">function	p=get_match(p)</a></li><li><a href="#_sub10" class="code">function	p=update(mode,p,varargin)</a></li><li><a href="#_sub11" class="code">function	p=show_res(mode,p,varargin)</a></li><li><a href="#_sub12" class="code">function	p=show_entry(mode,p,varargin)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% GREP</span>
0002 <span class="comment">%      a unix-like, very fast utility to find patterns</span>
0003 <span class="comment">%      in any files in folders and their subfolders</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% SYNTAX</span>
0006 <span class="comment">%      help</span>
0007 <span class="comment">%             GREP        show this screen</span>
0008 <span class="comment">%             GREP -p    show extended help for PATTERN/FILE</span>
0009 <span class="comment">%             GREP -f    show contents of output structure P</span>
0010 <span class="comment">%             GREP -e    show examples</span>
0011 <span class="comment">%      search</span>
0012 <span class="comment">%             GREP PATTERN FILE(*)</span>
0013 <span class="comment">%             GREP OPT1 ... OPTn PATTERN FILE(*)</span>
0014 <span class="comment">%        [FL,P] = GREP(PATTERN,FILE(*))</span>
0015 <span class="comment">%        [FL,P] = GREP({PATTERN(s)},{FILE1(*),...,FILEn(*)})</span>
0016 <span class="comment">%        [FL,P] = GREP(OPT1,...,OPTn,PATTERN,FILE)</span>
0017 <span class="comment">%        [FL,P] = GREP(OPT1,...,OPTn,{PATTERN(s)},{FILE1(*),...,FILEn(*)})</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% OPT    : arg    processing</span>
0020 <span class="comment">% ---------------------------------------------------------------------------------</span>
0021 <span class="comment">% -c    :    prints only a count of the lines that contain the pattern(s)</span>
0022 <span class="comment">% -D    :    debug mode: shows major processing steps</span>
0023 <span class="comment">% -d    :    debug mode: shows all   processing steps</span>
0024 <span class="comment">% -da    :    debug mode: shows all   output including debug messages</span>
0025 <span class="comment">% -e    :  PL    searches for a string in pattern-list PL or {PL1,...,PLn}</span>
0026 <span class="comment">%    : {PL}    useful syntax when the string contains an option flag character (-)</span>
0027 <span class="comment">%           multiple instances of &lt;-e PL&gt; and/or &lt;-e {PL,...}&gt; may be listed</span>
0028 <span class="comment">%       PL       searches for the first token in pattern without white spaces</span>
0029 <span class="comment">%      {PL}       searches for complete pattern(s) including white spaces</span>
0030 <span class="comment">% -f    :  PF    takes the list of patterns from ASCII pattern-file PF</span>
0031 <span class="comment">%           each line defines a single pattern that may include white spaces</span>
0032 <span class="comment">% -i    :    ignores upper/lower case distinction during comparisons</span>
0033 <span class="comment">% -I?    :  IL    only includes folders/files with at least one matching pattern</span>
0034 <span class="comment">%      {IL}       from IL or {IL1,...ILn}, which may include regular expressions</span>
0035 <span class="comment">%           multple instances of &lt;-I? IL&gt; and/or &lt;I? {IL,...}&gt; may be listed</span>
0036 <span class="comment">%   -Id    :    searches for inclusions in folders</span>
0037 <span class="comment">%   -If    :    searches for inclusions in file names</span>
0038 <span class="comment">%   -Ip    :    searches for inclusions in full paths: folder/filename</span>
0039 <span class="comment">% -l    :    prints the names of files with matching lines once</span>
0040 <span class="comment">% -n    :    precedes each line by its line number in the file</span>
0041 <span class="comment">% -Q    :    does not prefix output with file name</span>
0042 <span class="comment">% -R    :    uses the regular expression engine &lt;regexp&gt; [def: &lt;strfind&gt;]</span>
0043 <span class="comment">% -r    :    recursively searches in subfolder(s)</span>
0044 <span class="comment">% -s    :    works silently and displays only error messages</span>
0045 <span class="comment">% -u    :    does not produce underlined text</span>
0046 <span class="comment">% -V    :    prints name of each file before it is searched</span>
0047 <span class="comment">% -v    :    prints all lines except those that contain the pattern</span>
0048 <span class="comment">% -x    :    prints only lines that are matched entirely</span>
0049 <span class="comment">% -X?    :  XL    excludes folders/files with at least one matching pattern</span>
0050 <span class="comment">%      {XL}       from XL or {XL1,...XLn}, which may include regular expressions</span>
0051 <span class="comment">%           multple instances of &lt;-X? XL&gt; and/or &lt;X? {XL,...}&gt; may be listed</span>
0052 <span class="comment">%   -Xd    :    searches for exclusions in folders</span>
0053 <span class="comment">%   -Xf    :    searches for exclusions in file names</span>
0054 <span class="comment">%   -Xp    :    searches for exclusions in full paths: folder/filename</span>
0055 <span class="comment">%</span>
0056 <span class="comment">% NOTES        all folder separators are replaced by unix-style &lt;/&gt; to facilitate</span>
0057 <span class="comment">%           the use of regular expressions with &lt;-I?|X?&gt; options</span>
0058 <span class="comment">%        &lt;-I?|X?&gt; options allow wildcard searches using regular expressions</span>
0059 <span class="comment">%        clicking on underlined text opens the file at the matching line</span>
0060 
0061 <span class="comment">% created:</span>
0062 <span class="comment">%    us    14-Jan-1987</span>
0063 <span class="comment">% modified:</span>
0064 <span class="comment">%    us    04-Apr-2006 00:31:57</span>
0065 
0066 <span class="comment">%--------------------------------------------------------------------------------</span>
0067 <a name="_sub0" href="#_subfunctions" class="code">function    [pout,p]=grep(varargin)</a>
0068 
0069 <span class="comment">% program parameters</span>
0070         tim=clock;
0071         ver=<span class="string">'04-Apr-2006 00:31:57'</span>;
0072 
0073 <span class="comment">% option table</span>
0074         com=<span class="string">'command line'</span>;
0075     otbl={
0076 <span class="comment">%    flag    inival    nrpar    defpar    accum    desc</span>
0077 <span class="comment">%    -----------------------------------------------------------------------------------------</span>
0078     <span class="string">'-c'</span>    false    0    []    0    <span class="string">'count matches'</span>
0079     <span class="string">'-D'</span>    false    0    []    0    <span class="string">'major proc steps'</span>
0080     <span class="string">'-d'</span>    false    0    []    0    <span class="string">'minor proc steps'</span>
0081     <span class="string">'-da'</span>    false    0    []    0    <span class="string">'show all ouput including proc steps'</span>
0082     <span class="string">'-e'</span>    false    1    {}    1    <span class="string">'pattern list'</span>
0083     <span class="string">'-f'</span>    false    1    com    0    <span class="string">'pattern file'</span>
0084     <span class="string">'-i'</span>    false    0    []    0    <span class="string">'ignore case'</span>
0085     <span class="string">'-Id'</span>    false    1    {}    1    <span class="string">'only include folders with one matching token'</span>
0086     <span class="string">'-If'</span>    false    1    {}    1    <span class="string">'only include files with one matching token'</span>
0087     <span class="string">'-Ip'</span>    false    1    {}    1    <span class="string">'only include full paths with one matching token'</span>
0088     <span class="string">'-l'</span>    false    0    []    0    <span class="string">'print file name'</span>
0089     <span class="string">'-n'</span>    false    0    []    0    <span class="string">'print line number'</span>
0090     <span class="string">'-Q'</span>    false    0    []    0    <span class="string">'no file name prefix'</span>
0091     <span class="string">'-R'</span>    false    0    []    0    <span class="string">'regular expression engine'</span>
0092     <span class="string">'-r'</span>    false    0    []    0    <span class="string">'search in subfolders'</span>
0093     <span class="string">'-s'</span>    false    0    []    0    <span class="string">'quiet mode except error messages'</span>
0094     <span class="string">'-u'</span>    false    0    []    0    <span class="string">'does not produce underlined text'</span>
0095     <span class="string">'-V'</span>    false    0    []    0    <span class="string">'print file before search'</span>
0096     <span class="string">'-v'</span>    false    0    []    0    <span class="string">'print non-matching lines'</span>
0097     <span class="string">'-x'</span>    false    0    []    0    <span class="string">'complete match'</span>
0098     <span class="string">'-Xd'</span>    false    1    {}    1    <span class="string">'exclude folders with matching token'</span>
0099     <span class="string">'-Xf'</span>    false    1    {}    1    <span class="string">'exclude files with matching token'</span>
0100     <span class="string">'-Xp'</span>    false    1    {}    1    <span class="string">'exclude full paths with matching token'</span>
0101     };
0102 
0103     <span class="keyword">if</span>    nargout
0104         pout=[];
0105     <span class="keyword">end</span>
0106 
0107 <span class="comment">% initialize engine</span>
0108         p=<a href="#_sub2" class="code" title="subfunction    p=ini_par(ver,tim)">ini_par</a>(ver,tim);
0109         [p,msg]=<a href="#_sub3" class="code" title="subfunction    [p,msg]=set_opt(otbl,p,varargin)">set_opt</a>(otbl,p,varargin{:});
0110     <span class="keyword">if</span>    ~isempty(msg)
0111         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(100,p,msg);
0112     <span class="keyword">if</span>    nargout
0113         pout=p;
0114     <span class="keyword">end</span>
0115         <span class="keyword">return</span>;
0116     <span class="keyword">end</span>
0117         p.npat=p.opt.ns;
0118         p.pattern=p.opt.pattern(:);
0119         p.porigin=p.opt.f.val;
0120 
0121 <span class="comment">% get subfolders</span>
0122         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-100,p,sprintf(<span class="string">'GREP&gt; searching folders    ...'</span>));
0123         t1=clock;
0124         p=<a href="#_sub4" class="code" title="subfunction    p=get_folders(p)">get_folders</a>(p);
0125         p.runtime(2)=etime(clock,t1);
0126         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>( -99,p,sprintf(<span class="string">'GREP&gt; done %13.3f   %d folder(s)'</span>,p.runtime(1),p.nfolder));
0127 
0128 <span class="comment">% get files</span>
0129     <span class="keyword">if</span>    p.nfolder
0130         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>( -98,p,sprintf(<span class="string">'GREP&gt; searching files      ...'</span>));
0131         t1=clock;
0132         p=<a href="#_sub6" class="code" title="subfunction    p=get_files(p)">get_files</a>(p);
0133         p.runtime(3)=etime(clock,t1);
0134         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>( -97,p,sprintf(<span class="string">'GREP&gt; done %13.3f   %d file(s)'</span>,p.runtime(2),p.nfiles));
0135     <span class="keyword">end</span>
0136 
0137     <span class="keyword">if</span>    nargout
0138         pout=unique(p.files);
0139     <span class="keyword">end</span>
0140         p=<a href="#_sub2" class="code" title="subfunction    p=ini_par(ver,tim)">ini_par</a>(p);
0141         <span class="keyword">return</span>;
0142 <span class="comment">%--------------------------------------------------------------------------------</span>
0143 <span class="comment">%--------------------------------------------------------------------------------</span>
0144 <span class="comment">% SUBROUTINES</span>
0145 <span class="comment">%    - ehelp        extended help engine</span>
0146 <span class="comment">%    - ini_par    initialize structure</span>
0147 <span class="comment">%    - set_opt    input parser</span>
0148 <span class="comment">%    - get_folders    harvest input folders</span>
0149 <span class="comment">%    - get_folder    harvest subfolders/input folder</span>
0150 <span class="comment">%    - get_files    harvest files/input folder</span>
0151 <span class="comment">%    - get_file    harvest files</span>
0152 <span class="comment">%    - chk_path    check file/folder inclusion/exclusion</span>
0153 <span class="comment">%    - get_match    look for matches</span>
0154 <span class="comment">%    - update    update arrays</span>
0155 <span class="comment">%    - show_res    common display engine</span>
0156 <span class="comment">%    - show_entry    final  display engine</span>
0157 <span class="comment">%--------------------------------------------------------------------------------</span>
0158 <span class="comment">%--------------------------------------------------------------------------------</span>
0159 <a name="_sub1" href="#_subfunctions" class="code">function    p=ehelp(p,fnam,tag)</a>
0160 
0161         [fp,msg]=fopen(which(fnam),<span class="string">'rt'</span>);
0162     <span class="keyword">if</span>    fp &gt; 0
0163         hs=fread(fp,inf,<span class="string">'*char'</span>).';
0164         fclose(fp);
0165         ib=strfind(hs,tag);
0166     <span class="keyword">if</span>    isempty(ib)    ||<span class="keyword">...</span>
0167         numel(ib)&lt;2
0168         hs=sprintf(<span class="string">'GREP&gt; help sectio &lt;%s&gt; not found/not valid'</span>,tag);
0169     <span class="keyword">else</span>
0170         hs=hs(ib(end-1)+length(tag)+1:ib(end)-1);
0171         hs=strrep(hs,p.par.hdel,<span class="string">''</span>);
0172     <span class="keyword">end</span>
0173     <span class="keyword">else</span>
0174         hs=sprintf(<span class="string">'%s: &lt;%s&gt;'</span>,msg,fnam);
0175     <span class="keyword">end</span>
0176         disp(hs);
0177         <span class="keyword">return</span>;
0178 <span class="comment">%--------------------------------------------------------------------------------</span>
0179 <a name="_sub2" href="#_subfunctions" class="code">function    p=ini_par(ver,tim)</a>
0180 
0181 <span class="comment">% clean up</span>
0182     <span class="keyword">if</span>    isstruct(ver)
0183         p=ver;
0184         tim=p.par.tim;
0185         p.nxfolder=p.par.chkex(1);
0186         p.nxfiles=p.par.chkex(2);
0187         p.nafolder=p.nfolder+p.nxfolder;
0188         p.nafiles=p.nfiles+p.nxfiles;
0189         p.mdepth=max(p.fdepth);
0190     <span class="keyword">if</span>    ~isempty(p.result)
0191         p.result=char(p.result);
0192     <span class="keyword">end</span>
0193     <span class="keyword">if</span>    ~p.opt.D.flg    &amp;&amp;<span class="keyword">...</span>
0194         ~p.opt.d.flg
0195         p=rmfield(p,<span class="string">'par'</span>);
0196     <span class="keyword">end</span>
0197         p.runtime(1)=etime(clock,tim);
0198         <span class="keyword">return</span>;
0199     <span class="keyword">end</span>
0200 
0201 <span class="comment">% initialize common structure</span>
0202 <span class="comment">% - parameters</span>
0203         magic=<span class="string">'GREP'</span>;
0204         fsep=<span class="string">'/'</span>;
0205 
0206 <span class="comment">% - special characters</span>
0207 <span class="comment">%   - EOL UNIX        = LF</span>
0208 <span class="comment">%   - EOL WINDOWS    = CR+LF</span>
0209         par.tab=sprintf(<span class="string">'\t'</span>);    <span class="comment">% 009 = TAB: horizontal tab</span>
0210         par.cr=sprintf(<span class="string">'\r'</span>);    <span class="comment">% 013 =  CR: carriage return</span>
0211         par.lf=sprintf(<span class="string">'\n'</span>);    <span class="comment">% 010 =  LF: line feed</span>
0212         par.fsep=fsep;
0213         par.isold=0;
0214         par.nbytes=0;
0215         par.nlines=0;
0216         par.mfc=1;
0217         par.mlc=1;
0218         par.cd=[];
0219         par.cf=[];
0220         par.cn=[];
0221         par.cs=[];
0222         par.s=[];
0223         par.eol=[];
0224         par.chkpath=false;    <span class="comment">% true if I[]/X[] flags are set</span>
0225         par.chkex=[0,0];
0226         par.hasmatch=false;
0227         par.nmatch=0;
0228         par.hdel=<span class="string">'%$'</span>;
0229         par.reft=<span class="string">'&lt;a href=&quot;matlab:opentoline(''%s'',%-1d)&quot;&gt;%s&lt;/a&gt;: %s'</span>;
0230         par.tim=tim;
0231 
0232 <span class="comment">% ID</span>
0233         p.magic=magic;
0234         p.ver=ver;
0235         p.mver=version;
0236         p.rundate=datestr(tim);
0237         p.runtime=[0,0,0];
0238 <span class="comment">% parameters/options</span>
0239         p.opt=[];
0240         p.msg=[];
0241         p.par=par;
0242 
0243         p.section_1=<span class="string">'===== FOLDERS  ====='</span>;
0244         p.nfolder=0;
0245         p.nxfolder=0;
0246         p.nafolder=0;
0247         p.folder{1,1}=[];
0248         p.fenum=[];
0249         p.mdepth=0;
0250         p.fdepth(1,1)=0;
0251         p.section_2=<span class="string">'===== PATTERNS ====='</span>;
0252         p.npat=0;
0253         p.pattern={};
0254         p.porigin={};
0255         p.section_3=<span class="string">'===== FILES    ====='</span>;
0256         p.nfiles=0;
0257         p.nxfiles=0;
0258         p.nafiles=0;
0259         p.nbytes=0;
0260         p.nlines=0;
0261         p.section_4=<span class="string">'===== MATCHES  ====='</span>;
0262         p.mfiles=0;
0263         p.mbytes=0;
0264         p.mlines=0;
0265         p.pfiles=0;
0266         p.pcount=0;
0267         p.files={};
0268         p.lcount=[];
0269         p.findex=[];
0270         p.pindex=[];
0271         p.line=[];
0272         p.match={};
0273         p.result={};
0274         <span class="keyword">return</span>;
0275 <span class="comment">%--------------------------------------------------------------------------------</span>
0276 <a name="_sub3" href="#_subfunctions" class="code">function    [p,msg]=set_opt(otbl,p,varargin)</a>
0277 
0278         o=[];
0279         msg=[];
0280 
0281 <span class="comment">% set options</span>
0282 <span class="comment">% ...default options</span>
0283         o.des1=<span class="string">'===== OPTIONS ====='</span>;
0284     <span class="keyword">for</span>    i=1:size(otbl,1)
0285         fn=otbl{i,1}(2:end);
0286         o.(fn).flg=otbl{i,2};
0287         o.(fn).acc=otbl{i,5};
0288         o.(fn).des=otbl{i,6};
0289         o.(fn).def=otbl{i,4};
0290         o.(fn).val=otbl{i,4};
0291     <span class="keyword">end</span>
0292 
0293         argn=numel(varargin);
0294     <span class="keyword">if</span>    argn &lt; 2
0295     <span class="keyword">if</span>    ~argn
0296         help(mfilename);
0297         msg=sprintf(<span class="string">'GREP&gt; needs at least two arguments'</span>);
0298     <span class="keyword">elseif</span>    numel(varargin{1}) &gt; 1
0299     <span class="keyword">switch</span>    lower(varargin{1}(1:2))
0300     <span class="keyword">case</span>    {<span class="string">'-p'</span>}
0301         <a href="#_sub1" class="code" title="subfunction    p=ehelp(p,fnam,tag)">ehelp</a>(p,mfilename,<span class="string">'___FORMAT___'</span>);
0302         msg=true;
0303     <span class="keyword">case</span>    {<span class="string">'-e'</span>}
0304         <a href="#_sub1" class="code" title="subfunction    p=ehelp(p,fnam,tag)">ehelp</a>(p,mfilename,<span class="string">'___EXAMPLE___'</span>);
0305         msg=true;
0306     <span class="keyword">case</span>    {<span class="string">'-f'</span>}
0307         <a href="#_sub1" class="code" title="subfunction    p=ehelp(p,fnam,tag)">ehelp</a>(p,mfilename,<span class="string">'___OUTPUT___'</span>);
0308         msg=true;
0309     <span class="keyword">otherwise</span>
0310         help(mfilename);
0311         msg=sprintf(<span class="string">'GREP&gt; needs at least two arguments'</span>);
0312     <span class="keyword">end</span>
0313     <span class="keyword">else</span>
0314         help(mfilename);
0315         msg=sprintf(<span class="string">'GREP&gt; needs at least two arguments'</span>);
0316     <span class="keyword">end</span>
0317         p.opt=o;
0318         <span class="keyword">return</span>;
0319     <span class="keyword">end</span>
0320 
0321 <span class="comment">% ...user defined options</span>
0322 <span class="comment">% ...must account for syntax of various forms</span>
0323 <span class="comment">%    ('-a -b +c -d','-f',xxx,'-g +h',...)</span>
0324 
0325 <span class="comment">% ...reconstruct &lt;varargin&gt; as a string</span>
0326         pat=sprintf(<span class="string">'GREP&gt;ARG|%20.19f['</span>,rand);
0327         arg=varargin;
0328         ic=cellfun(@(x) [pat,class(x),<span class="string">']'</span>],arg,<span class="string">'uniformoutput'</span>,false);
0329         il=cellfun(<span class="string">'isclass'</span>,arg,<span class="string">'char'</span>);
0330         ic(il)=arg(il);
0331         ic=sprintf(<span class="string">'%s '</span>,ic{:});
0332         ic=strread(ic,<span class="string">'%s'</span>);
0333         [ox,io]=ismember(ic,otbl(:,1));        <span class="comment">%#ok MLINT 2006a</span>
0334         ox=io(io&gt;0);
0335         ax=find(io);
0336         argn=numel(ic);
0337         iv=strfind(ic,pat);
0338         iv=~cellfun(<span class="string">'isempty'</span>,iv);
0339         ic(iv)=arg(~il);
0340 
0341     <span class="keyword">for</span>    i=1:numel(ox)
0342         ix=ox(i);
0343         fn=otbl{ix,1}(2:end);
0344         o.(fn).flg=xor(otbl{ix,2},1);
0345     <span class="keyword">if</span>    otbl{ix,3} &gt; 0
0346         vx=ax(i)+1:ax(i)+otbl{ix,3};
0347     <span class="keyword">if</span>    vx(end) &lt;= argn
0348     <span class="keyword">if</span>    o.(fn).acc
0349     <span class="keyword">if</span>    ~iscell(ic(vx))
0350         ic(vx)={ic(vx)};
0351         o.(fn).val=[o.(fn).val;{ic(vx)}];
0352     <span class="keyword">else</span>
0353         o.(fn).val=[o.(fn).val,ic{vx}];
0354     <span class="keyword">end</span>
0355     <span class="keyword">else</span>
0356         o.(fn).val=ic(vx);
0357     <span class="keyword">end</span>
0358     <span class="keyword">else</span>
0359         o.(fn).flg=otbl{ix,2};
0360         msg=sprintf(<span class="string">'GREP&gt; parameter(s) missing for option &lt;%s&gt; [%-1d]'</span>,<span class="keyword">...</span>
0361                 otbl{ix,1},otbl{ix,3});
0362     <span class="keyword">end</span>
0363     <span class="keyword">end</span>
0364     <span class="keyword">end</span>
0365 
0366     <span class="keyword">if</span>    o.Id.flg    ||<span class="keyword">...</span>
0367         o.If.flg    ||<span class="keyword">...</span>
0368         o.Ip.flg    ||<span class="keyword">...</span>
0369         o.Xd.flg    ||<span class="keyword">...</span>
0370         o.Xf.flg    ||<span class="keyword">...</span>
0371         o.Xp.flg
0372         p.par.chkpath=true;
0373     <span class="keyword">end</span>
0374 
0375 <span class="comment">% get search template(s)/file(s)</span>
0376 <span class="comment">% ...templates</span>
0377         o.des2=<span class="string">'===== INPUT ====='</span>;
0378         o.arg={};
0379         o.ns=0;
0380         o.pattern=varargin{end-1};
0381         o.nf=0;
0382         o.files=varargin{end};
0383 
0384     <span class="keyword">if</span>    ~iscell(o.pattern)
0385         o.pattern={o.pattern};
0386     <span class="keyword">end</span>
0387     <span class="keyword">if</span>    o.e.flg
0388         o.pattern=o.e.val;
0389     <span class="keyword">end</span>
0390     <span class="keyword">if</span>    o.f.flg
0391     <span class="keyword">if</span>    iscell(o.f.val{1})
0392         o.f.val{1}=o.f.val{1}{:};
0393     <span class="keyword">end</span>
0394         pnam=o.f.val{1};
0395     <span class="keyword">if</span>    exist(pnam,<span class="string">'file'</span>)
0396         o.pattern=textread(pnam,<span class="string">'%s'</span>,<span class="string">'delimiter'</span>,<span class="string">'\n'</span>,<span class="string">'whitespace'</span>,<span class="string">''</span>);
0397     <span class="keyword">else</span>
0398         msg=sprintf(<span class="string">'GREP&gt; pattern file not existing &lt;%s&gt;'</span>,pnam);
0399     <span class="keyword">end</span>
0400     <span class="keyword">end</span>
0401         o.ns=numel(o.pattern);
0402         o.arg=ic;
0403 
0404 <span class="comment">% ...files</span>
0405     <span class="keyword">if</span>    ~iscell(o.files)
0406         o.files={o.files};
0407     <span class="keyword">end</span>
0408         o.files=o.files(:);
0409         o.ns=numel(o.pattern);
0410         o.nf=numel(o.files);
0411 
0412     <span class="keyword">for</span>    i=1:o.nf
0413     <span class="keyword">if</span>    isempty(o.files{i})
0414         o.files{i}=[cd,p.par.fsep,<span class="string">'*.*'</span>];
0415     <span class="keyword">end</span>
0416     <span class="keyword">if</span>    o.files{i}(end)==<span class="string">'/'</span>    ||<span class="keyword">...</span>
0417         o.files{i}(end)==<span class="string">'\'</span>
0418         o.files{i}=o.files{i}(1:end-1);
0419     <span class="keyword">end</span>
0420         o.fpat{i}=o.files{i};
0421         o.fnam{i}=<span class="string">'*.*'</span>;
0422         o.fext{i}=<span class="string">'.*'</span>;
0423     <span class="keyword">if</span>    strcmp(o.fpat{i},<span class="string">'.'</span>)
0424         o.fpat{i}=cd;
0425     <span class="keyword">end</span>
0426     <span class="keyword">if</span>    ~exist(o.files{i},<span class="string">'dir'</span>)
0427         [o.fpat{i},o.fnam{i},o.fext{i}]=fileparts(o.files{i});
0428     <span class="keyword">if</span>    isempty(o.fpat{i})
0429         o.fpat{i}=cd;
0430     <span class="keyword">end</span>
0431     <span class="keyword">if</span>    isempty(o.fnam{i})
0432         o.fnam{i}=<span class="string">'*'</span>;
0433     <span class="keyword">end</span>
0434     <span class="keyword">if</span>    isempty(o.fext{i})
0435         o.fext{i}=<span class="string">'.*'</span>;
0436     <span class="keyword">end</span>
0437         o.fnam{i}=[o.fnam{i},o.fext{i}];
0438     <span class="keyword">end</span>
0439     <span class="keyword">end</span>
0440 
0441 <span class="comment">% ...remove dup folders</span>
0442         o.npat=0;
0443         o.xpat=1;
0444         o.upat=1;
0445         [o.fpat,ix]=sort(o.fpat(:));
0446         o.files=o.files(ix);
0447         o.fnam=o.fnam(ix);
0448         o.fext=o.fext(ix);
0449         [o.npat,o.npat,o.xpat]=unique(o.fpat);
0450         o.npat=numel(o.npat);
0451         o.upat=find([1;diff(o.xpat)]&gt;0);
0452 
0453         p.opt=o;
0454         <span class="keyword">return</span>;
0455 <span class="comment">%--------------------------------------------------------------------------------</span>
0456 <a name="_sub4" href="#_subfunctions" class="code">function    p=get_folders(p)</a>
0457 
0458     <span class="keyword">for</span>    i=1:p.opt.npat
0459         cf=p.opt.fpat{p.opt.upat(i)};
0460         cf=strrep(cf,filesep,p.par.fsep);
0461         p=<a href="#_sub5" class="code" title="subfunction    p=get_folder(p,frot,crot,depth,ix)">get_folder</a>(p,cf,cf,0,i);
0462     <span class="keyword">end</span>
0463         <span class="keyword">return</span>;
0464 <span class="comment">%--------------------------------------------------------------------------------</span>
0465 <a name="_sub5" href="#_subfunctions" class="code">function    p=get_folder(p,frot,crot,depth,ix)</a>
0466 
0467 <span class="comment">% recursively find all subfolders of a root</span>
0468 <span class="comment">% note    we CANNOT use &lt;genpath&gt; as it does not return all subfolders!</span>
0469 <span class="comment">%    eg,</span>
0470 <span class="comment">%    - @class  subfolders</span>
0471 <span class="comment">%    - private subfolders</span>
0472 
0473 <span class="comment">% root folders</span>
0474     <span class="keyword">if</span>    ~depth
0475         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-10,p,sprintf(<span class="string">'GREP&gt; folder              &lt;%s&gt;'</span>,frot));
0476     <span class="keyword">if</span>    exist(frot,<span class="string">'dir'</span>)
0477         [tf,p]=<a href="#_sub8" class="code" title="subfunction    [tf,p]=chk_path(mode,p,fnam,frot)">chk_path</a>(1,p,frot,<span class="string">'***FOLDER***'</span>);
0478     <span class="keyword">if</span>    tf
0479         p.nfolder=p.nfolder+1;
0480         p.folder{p.nfolder,1}=strrep(frot,filesep,p.par.fsep);
0481         p.fenum(p.nfolder,1)=ix;
0482     <span class="keyword">end</span>
0483     <span class="keyword">else</span>
0484         msg=sprintf(<span class="string">'GREP&gt; folder not found &lt;%s&gt;'</span>,frot);
0485         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(100,p,msg);
0486     <span class="keyword">end</span>
0487     <span class="keyword">end</span>
0488 
0489     <span class="keyword">if</span>    ~p.opt.r.flg
0490         <span class="keyword">return</span>;
0491     <span class="keyword">end</span>
0492 
0493 <span class="comment">% subfolders</span>
0494         rd=dir(crot);
0495         rx=[rd.isdir]==1;
0496         rd=rd(rx);
0497         nd=numel(rd);
0498     <span class="keyword">for</span>    i=1:nd
0499     <span class="keyword">if</span>    rd(i).isdir &amp;&amp; ~all(rd(i).name==<span class="string">'.'</span>)    <span class="comment">% rd(i).name(1) ~= '.'</span>
0500     <span class="keyword">if</span>    ~isempty(crot)
0501         nrot=[crot,p.par.fsep,rd(i).name];
0502     <span class="keyword">else</span>
0503         nrot=rd(i).name;
0504     <span class="keyword">end</span>
0505         nrot=strrep(nrot,filesep,p.par.fsep);
0506         [tf,p]=<a href="#_sub8" class="code" title="subfunction    [tf,p]=chk_path(mode,p,fnam,frot)">chk_path</a>(1,p,nrot,<span class="string">'***SUBFOLDER***'</span>);
0507     <span class="keyword">if</span>    tf
0508         p.nfolder=p.nfolder+1;
0509         depth=depth+1;
0510         p.fdepth(p.nfolder,1)=depth;
0511         p.folder{p.nfolder,1}=strrep(nrot,filesep,p.par.fsep);
0512         p.fenum(p.nfolder,1)=ix;
0513         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-9,p,sprintf(<span class="string">'- subfolder %5d/%6d  &lt;%s&gt;'</span>,depth,p.nfolder,nrot));
0514         p=<a href="#_sub5" class="code" title="subfunction    p=get_folder(p,frot,crot,depth,ix)">get_folder</a>(p,frot,nrot,depth,ix);
0515         depth=depth-1;
0516     <span class="keyword">end</span>
0517     <span class="keyword">end</span>
0518     <span class="keyword">end</span>
0519     <span class="keyword">if</span>    ~depth
0520         p.par.isold=0;
0521     <span class="keyword">end</span>
0522         <span class="keyword">return</span>;
0523 <span class="comment">%--------------------------------------------------------------------------------</span>
0524 <a name="_sub6" href="#_subfunctions" class="code">function    p=get_files(p)</a>
0525 
0526     <span class="keyword">for</span>    i=1:p.opt.nf
0527         cn=p.opt.fnam{i};
0528         fx=find(p.fenum==p.opt.xpat(i));
0529         cp=p.folder(fx);
0530     <span class="keyword">for</span>    j=1:numel(fx)
0531         p.par.cd=cp{j};
0532         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-8,p,sprintf(<span class="string">'GREP&gt; files %5d/%7d &lt;%s:%s&gt;'</span>,i,j,p.par.cd,cn));
0533         d=dir([p.par.cd,p.par.fsep,cn]);
0534     <span class="keyword">if</span>    ~isempty(d)
0535     <span class="keyword">for</span>    k=1:numel(d)
0536     <span class="keyword">if</span>    ~d(k).isdir
0537         p.par.cf=[p.par.cd,p.par.fsep,d(k).name];
0538         p.par.cn=d(k).name;
0539         [tf,p]=<a href="#_sub8" class="code" title="subfunction    [tf,p]=chk_path(mode,p,fnam,frot)">chk_path</a>(2,p,p.par.cf,p.par.cn);
0540     <span class="keyword">if</span>    tf
0541         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-7,p,sprintf(<span class="string">'- file      %7d/%7d &lt;%s&gt;'</span>,k,numel(d),p.par.cf));
0542         p=<a href="#_sub7" class="code" title="subfunction    p=get_file(p)">get_file</a>(p);
0543     <span class="keyword">end</span>
0544     <span class="keyword">end</span>
0545     <span class="keyword">end</span>
0546     <span class="keyword">end</span>
0547     <span class="keyword">end</span>
0548     <span class="keyword">end</span>
0549         <span class="keyword">return</span>;
0550 <span class="comment">%--------------------------------------------------------------------------------</span>
0551 <a name="_sub7" href="#_subfunctions" class="code">function    p=get_file(p)</a>
0552 
0553 <span class="comment">%D    if    exist(p.par.cf,'file')</span>
0554         [fp,msg]=fopen(p.par.cf,<span class="string">'rb'</span>);
0555     <span class="keyword">if</span>    fp &lt; 0
0556         msg=sprintf(<span class="string">'GREP&gt; cannot open file &lt;%s&gt;\nGREP&gt; %s'</span>,p.par.cf,msg);
0557         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(100,p,msg);
0558     <span class="keyword">else</span>
0559         p.par.s=fread(fp,inf,<span class="string">'*char'</span>).';
0560         fclose(fp);
0561         p.par.nbytes=numel(p.par.s);
0562     <span class="keyword">if</span>    ispc
0563         p.par.s=strrep(p.par.s,[p.par.cr,p.par.lf],p.par.lf);
0564     <span class="keyword">end</span>
0565         p.par.s=strrep(p.par.s,char(0),<span class="string">'^'</span>);
0566         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(2,p);
0567         p=<a href="#_sub9" class="code" title="subfunction    p=get_match(p)">get_match</a>(p);
0568     <span class="keyword">end</span>
0569 <span class="comment">%D    end</span>
0570         <span class="keyword">return</span>;
0571 <span class="comment">%--------------------------------------------------------------------------------</span>
0572 <a name="_sub8" href="#_subfunctions" class="code">function    [tf,p]=chk_path(mode,p,fnam,frot)</a>
0573 
0574         tf=true;
0575 <span class="comment">% - escape immediately if user did not choose inclusion/exclusion flags</span>
0576     <span class="keyword">if</span>    ~p.par.chkpath
0577         <span class="keyword">return</span>;
0578     <span class="keyword">end</span>
0579 
0580         ixi=true;
0581         ixe=false;
0582     <span class="keyword">switch</span>    mode
0583 <span class="comment">% include/exclude folders</span>
0584     <span class="keyword">case</span>    1
0585         smode=<span class="string">'FOLDER'</span>;
0586     <span class="keyword">if</span>    p.opt.Id.flg
0587         ix=regexp(fnam,p.opt.Id.val);
0588         ixi=any(~cellfun(<span class="string">'isempty'</span>,ix));
0589     <span class="keyword">end</span>
0590     <span class="keyword">if</span>    ixi
0591     <span class="keyword">if</span>    p.opt.Xd.flg
0592         ix=regexp(fnam,p.opt.Xd.val);
0593         ixe=any(~cellfun(<span class="string">'isempty'</span>,ix));
0594     <span class="keyword">end</span>
0595     <span class="keyword">end</span>
0596 <span class="comment">% incrementally include/exclude files/full paths</span>
0597     <span class="keyword">case</span>    2
0598         smode=<span class="string">'FILE'</span>;
0599     <span class="keyword">if</span>    p.opt.If.flg
0600         ix=regexp(frot,p.opt.If.val);
0601         ixi=any(~cellfun(<span class="string">'isempty'</span>,ix));
0602     <span class="keyword">end</span>
0603     <span class="keyword">if</span>    ixi
0604     <span class="keyword">if</span>    p.opt.Xf.flg
0605         ix=regexp(frot,p.opt.Xf.val);
0606         ixe=any(~cellfun(<span class="string">'isempty'</span>,ix));
0607     <span class="keyword">end</span>
0608     <span class="keyword">if</span>    ~ixe
0609         smode=<span class="string">'PATH'</span>;
0610     <span class="keyword">if</span>    p.opt.Ip.flg
0611         ix=regexp(fnam,p.opt.Ip.val);
0612         ixi=any(~cellfun(<span class="string">'isempty'</span>,ix));
0613     <span class="keyword">end</span>
0614     <span class="keyword">if</span>    ixi
0615     <span class="keyword">if</span>    p.opt.Xp.flg
0616         ix=regexp(fnam,p.opt.Xp.val);
0617         ixe=any(~cellfun(<span class="string">'isempty'</span>,ix));
0618     <span class="keyword">end</span>    <span class="comment">% does not match PATH Xp</span>
0619     <span class="keyword">end</span>    <span class="comment">% does not macht PATH Ip</span>
0620     <span class="keyword">end</span>    <span class="comment">% does not match FILE Xf</span>
0621     <span class="keyword">end</span>    <span class="comment">% does not match FILE If</span>
0622 
0623     <span class="keyword">end</span>    <span class="comment">% switch</span>
0624 
0625     <span class="keyword">if</span>    ~ixi        ||<span class="keyword">...</span>
0626         ixe
0627         p.par.chkex(mode)=p.par.chkex(mode)+1;
0628         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-50,p,sprintf(<span class="string">'* exclude %7.7s         &lt;%s&gt;'</span>,smode,fnam));
0629         tf=false;
0630     <span class="keyword">end</span>
0631         <span class="keyword">return</span>;
0632 <span class="comment">%--------------------------------------------------------------------------------</span>
0633 <a name="_sub9" href="#_subfunctions" class="code">function    p=get_match(p)</a>
0634 
0635         p.par.hasmatch=false;
0636         s=p.par.s;
0637     <span class="keyword">if</span>    p.opt.i.flg
0638         s=lower(s);
0639     <span class="keyword">end</span>
0640 <span class="comment">% find EOL marker(s)</span>
0641         p.par.eol=[0,strfind(s,p.par.lf),numel(s)+1];
0642         p.par.nlines=numel(p.par.eol)-2;
0643         p.nfiles=p.nfiles+1;
0644         p.nbytes=p.nbytes+p.par.nbytes;
0645         p.nlines=p.nlines+p.par.nlines;
0646 
0647     <span class="keyword">for</span>    j=1:p.opt.ns
0648         str=p.opt.pattern{j};
0649     <span class="keyword">if</span>    p.opt.i.flg
0650         str=lower(str);
0651     <span class="keyword">end</span>
0652         p.par.cs=str;
0653 
0654 <span class="comment">% find string pattern &lt;str&gt;</span>
0655     <span class="keyword">if</span>    p.opt.R.flg
0656         ix=regexp(s,str);
0657     <span class="keyword">else</span>
0658         ix=strfind(s,str);
0659     <span class="keyword">end</span>
0660 
0661         p.par.nmatch=0;
0662     <span class="keyword">if</span>    ~isempty(ix)
0663 
0664 <span class="comment">% ...find line(s)</span>
0665         [lx,lx]=histc(ix,p.par.eol);    <span class="comment">%#ok MLINT 2006a</span>
0666         lx=lx(find([diff(lx),1]));    <span class="comment">%#ok MLINT 2006a</span>
0667 
0668 <span class="comment">% ...-v: only print non-matching lines</span>
0669     <span class="keyword">if</span>    p.opt.v.flg
0670         tl=1:numel(p.par.eol)-2;
0671         ll=tl~=0;
0672         ll(lx)=false;
0673         lx=tl(ll);
0674     <span class="keyword">end</span>
0675 
0676         nx=numel(lx);
0677     <span class="keyword">if</span>    nx
0678         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(-2,p,lx,0);
0679     <span class="keyword">for</span>    i=1:nx
0680         sx=p.par.eol(lx(i))+1:p.par.eol(lx(i)+1)-1;
0681         nl=lx(i);
0682         nm=p.par.s(sx);
0683 
0684 <span class="comment">% ...-x: only print fully matching lines</span>
0685     <span class="keyword">if</span>    ~p.opt.x.flg    ||<span class="keyword">...</span>
0686         numel(sx)==numel(str)
0687         p.par.nmatch=p.par.nmatch+1;
0688         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(3,p,nl,nm);
0689     <span class="keyword">if</span>    ~p.opt.c.flg    ||<span class="keyword">...</span>
0690         i==1
0691         p=<a href="#_sub10" class="code" title="subfunction    p=update(mode,p,varargin)">update</a>(3,p,nl,nm);
0692     <span class="keyword">end</span>
0693     <span class="keyword">end</span>
0694     <span class="keyword">end</span>    <span class="comment">% each    match</span>
0695     <span class="keyword">end</span>    <span class="comment">% found match</span>
0696     <span class="keyword">end</span>    <span class="comment">% found matches</span>
0697 
0698     <span class="keyword">if</span>    p.par.nmatch
0699         p.par.hasmatch=true;
0700         p.pfiles=p.pfiles+1;
0701         p.pcount=p.pcount+nx;
0702         p.files(p.pfiles,1)={p.par.cf};
0703         p.lcount(p.pfiles,1)=nx;
0704         p.findex=[p.findex;repmat(p.pfiles,nx,1)];
0705         p.pindex=[p.pindex;repmat(j,nx,1)];
0706     <span class="keyword">if</span>    p.opt.c.flg
0707         p=<a href="#_sub11" class="code" title="subfunction    p=show_res(mode,p,varargin)">show_res</a>(4,p);
0708     <span class="keyword">end</span>
0709     <span class="keyword">end</span>
0710 
0711     <span class="keyword">end</span>    <span class="comment">% for each &lt;string&gt;</span>
0712 
0713     <span class="keyword">if</span>    p.par.hasmatch
0714         p.mfiles=p.mfiles+1;
0715         p.mbytes=p.mbytes+p.par.nbytes;
0716         p.mlines=p.mlines+p.par.nlines;
0717     <span class="keyword">end</span>
0718 
0719         <span class="keyword">return</span>;
0720 <span class="comment">%--------------------------------------------------------------------------------</span>
0721 <a name="_sub10" href="#_subfunctions" class="code">function    p=update(mode,p,varargin)</a>
0722 
0723     <span class="keyword">switch</span>    mode
0724     <span class="keyword">case</span>    3
0725         p.line(p.par.mlc,1)=varargin{1};
0726         p.match(p.par.mlc,1)={varargin{2}};
0727         p.par.mlc=p.par.mlc+1;
0728     <span class="keyword">case</span>    4
0729         p.result(p.par.mfc,1)={varargin{1}};
0730         p.par.mfc=p.par.mfc+1;
0731     <span class="keyword">end</span>
0732         <span class="keyword">return</span>;
0733 <span class="comment">%--------------------------------------------------------------------------------</span>
0734 <a name="_sub11" href="#_subfunctions" class="code">function    p=show_res(mode,p,varargin)</a>
0735 
0736 <span class="comment">% common output engine</span>
0737 
0738 <span class="comment">%    mode    display entity</span>
0739 <span class="comment">%    -100    subfolder engine start</span>
0740 <span class="comment">%    -99    subfolder engine end</span>
0741 <span class="comment">%    -98    match engine start</span>
0742 <span class="comment">%    -97    match engine end</span>
0743 <span class="comment">%    -50    exclude folder/file</span>
0744 <span class="comment">%    -10    folder</span>
0745 <span class="comment">%    -9    subfolder</span>
0746 <span class="comment">%    -8    current folder</span>
0747 <span class="comment">%    -7    current file</span>
0748 <span class="comment">%    -2    match</span>
0749 <span class="comment">%    2    file before search</span>
0750 <span class="comment">%    3    line</span>
0751 <span class="comment">%    4    line count only</span>
0752 <span class="comment">%    100    error message</span>
0753 
0754 <span class="comment">% display all ouput</span>
0755         <span class="keyword">if</span>    p.opt.da.flg
0756             p=<a href="#_sub12" class="code" title="subfunction    p=show_entry(mode,p,varargin)">show_entry</a>(mode,p,varargin{:});
0757             <span class="keyword">return</span>;
0758         <span class="keyword">end</span>
0759 
0760 <span class="comment">% display selected ouput only</span>
0761         <span class="keyword">if</span>    p.opt.s.flg    &amp;&amp;<span class="keyword">...</span>
0762             mode &lt; 100
0763             <span class="keyword">return</span>;
0764         <span class="keyword">else</span>
0765         <span class="keyword">if</span>    mode &lt; -10
0766         <span class="keyword">if</span>    ~p.opt.D.flg    &amp;&amp;<span class="keyword">...</span>
0767             ~p.opt.d.flg
0768             <span class="keyword">return</span>;
0769         <span class="keyword">end</span>
0770         <span class="keyword">elseif</span>    mode &lt; 0
0771         <span class="keyword">if</span>    ~p.opt.d.flg
0772             <span class="keyword">return</span>;
0773         <span class="keyword">end</span>
0774         <span class="keyword">end</span>
0775         <span class="keyword">end</span>
0776             p=<a href="#_sub12" class="code" title="subfunction    p=show_entry(mode,p,varargin)">show_entry</a>(mode,p,varargin{:});
0777             <span class="keyword">return</span>;
0778 <span class="comment">%--------------------------------------------------------------------------------</span>
0779 <a name="_sub12" href="#_subfunctions" class="code">function    p=show_entry(mode,p,varargin)</a>
0780 
0781             str=[];
0782             txt=[];        <span class="comment">%#ok MLINT 2006a</span>
0783             ref=[];
0784     <span class="keyword">switch</span>    mode
0785     <span class="keyword">case</span>    {-100 -99 -98 -97 -50 -10 -9 -8 -7}
0786             str=varargin{1};
0787     <span class="keyword">case</span>    -2
0788             str=sprintf(<span class="string">'+ match  %16d &lt;%s&gt;'</span>,numel(varargin{1}),p.par.cf);
0789     <span class="keyword">case</span>    2
0790         <span class="keyword">if</span>    p.opt.V.flg
0791             str=sprintf(<span class="string">'%s'</span>,p.par.cf);
0792         <span class="keyword">end</span>
0793     <span class="keyword">case</span>    3
0794         <span class="keyword">if</span>    p.opt.l.flg    &amp;&amp;<span class="keyword">...</span>
0795             p.par.nmatch==1
0796             str=sprintf(<span class="string">'%s [%s]'</span>,p.par.cf,p.par.cs);
0797         <span class="keyword">end</span>
0798         <span class="keyword">if</span>    ~p.opt.c.flg
0799         <span class="keyword">if</span>    p.opt.D.flg    ||<span class="keyword">...</span>
0800             p.opt.d.flg
0801             ref=sprintf(<span class="string">'%17d'</span>,varargin{1});
0802             txt=sprintf(<span class="string">'%17d:      &lt;%s&gt;'</span>,varargin{1},varargin{2});
0803         <span class="keyword">elseif</span>    p.opt.n.flg    &amp;&amp;<span class="keyword">...</span>
0804             ~p.opt.Q.flg
0805             ref=sprintf(<span class="string">'%s:%-1d'</span>,p.par.cn,varargin{1});
0806             txt=sprintf(<span class="string">'%s:%-1d: %s'</span>,p.par.cn,varargin{1},varargin{2});
0807         <span class="keyword">elseif</span>    p.opt.n.flg    &amp;&amp;<span class="keyword">...</span>
0808             p.opt.Q.flg
0809             ref=sprintf(<span class="string">'%-1d'</span>,varargin{1});
0810             txt=sprintf(<span class="string">'%-1d: %s'</span>,varargin{1},varargin{2});
0811         <span class="keyword">elseif</span>    ~p.opt.Q.flg
0812             ref=sprintf(<span class="string">'%s'</span>,p.par.cn);
0813             txt=sprintf(<span class="string">'%s: %s'</span>,p.par.cn,varargin{2});
0814         <span class="keyword">else</span>
0815             txt=sprintf(<span class="string">'%s'</span>,varargin{2});
0816         <span class="keyword">end</span>
0817         <span class="keyword">if</span>    ~isempty(ref)
0818         <span class="keyword">if</span>    ~p.opt.u.flg
0819             txt=sprintf(p.par.reft,p.par.cf,varargin{1},ref,varargin{2});
0820         <span class="keyword">end</span>
0821         <span class="keyword">end</span>
0822         <span class="keyword">if</span>    ~isempty(str)
0823             str=str2mat(str,txt);
0824         <span class="keyword">else</span>
0825             str=txt;
0826         <span class="keyword">end</span>
0827         <span class="keyword">end</span>
0828     <span class="keyword">case</span>    4
0829         <span class="keyword">if</span>    p.opt.c.flg
0830             str=sprintf(<span class="string">'%-d'</span>,p.lcount(p.pfiles));
0831         <span class="keyword">end</span>
0832     <span class="keyword">case</span>    100
0833             p.msg=varargin{1};
0834         <span class="keyword">if</span>    ischar(p.msg)
0835             str=p.msg;
0836         <span class="keyword">end</span>
0837     <span class="keyword">end</span>
0838 
0839         <span class="keyword">if</span>    ~isempty(str)
0840             p=<a href="#_sub10" class="code" title="subfunction    p=update(mode,p,varargin)">update</a>(4,p,str);
0841             disp(str);
0842         <span class="keyword">end</span>
0843             <span class="keyword">return</span>;
0844 <span class="comment">%--------------------------------------------------------------------------------</span>
0845 <span class="comment">%--------------------------------------------------------------------------------</span>
0846 <span class="comment">% EXTENDED HELP SECTION</span>
0847 <span class="comment">%    formatted for pretty output</span>
0848 <span class="comment">%    do NOT change alignment</span>
0849 <span class="comment">%--------------------------------------------------------------------------------</span>
0850 <span class="comment">%    BOL delimiter    %$</span>
0851 <span class="comment">%    tag        contents</span>
0852 <span class="comment">%    ___FORMAT___    input formats</span>
0853 <span class="comment">%    ___OUTPUT___    P.field explanations</span>
0854 <span class="comment">%    ___EXAMPLE___    examples</span>
0855 
0856 <span class="comment">%{</span>
0857 <span class="comment">%$___FORMAT___</span>
0858 <span class="comment">%$  SYNTAX</span>
0859 <span class="comment">%$             grep PATTERN FILE</span>
0860 <span class="comment">%$             grep OPT1 ... OPTn PATTERN FILE</span>
0861 <span class="comment">%$        [FL,P] = grep(PATTERN,FILE)</span>
0862 <span class="comment">%$        [FL,P] = grep({PATTERN(s)}, {FILE(s)})</span>
0863 <span class="comment">%$        [FL,P] = grep(OPT1, ..., OPTn, PATTERN, FILE)</span>
0864 <span class="comment">%$        [FL,P] = grep(OPT1,...,OPTn,{PATTERN(s)},{FILE(s)})</span>
0865 <span class="comment">%$</span>
0866 <span class="comment">%$  input arguments/formats</span>
0867 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
0868 <span class="comment">%$  OPT</span>
0869 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
0870 <span class="comment">%$    for available options,</span>
0871 <span class="comment">%$    see &lt;grep&gt; or &lt;help grep&gt;</span>
0872 <span class="comment">%$</span>
0873 <span class="comment">%$    any mixture of    ...,'-a -b -d','-k','-y -z',...</span>
0874 <span class="comment">%$</span>
0875 <span class="comment">%$    note    the input parser will tokenize strings</span>
0876 <span class="comment">%$           into single options and other arguments</span>
0877 <span class="comment">%$           see: &lt;P.opt.arg&gt; for parsing results</span>
0878 <span class="comment">%$</span>
0879 <span class="comment">%$    special cases</span>
0880 <span class="comment">%$</span>
0881 <span class="comment">%$    -e    '-e -l'</span>
0882 <span class="comment">%$        add pattern &lt;-l&gt; AND    set option [-l]</span>
0883 <span class="comment">%$        '-e',{'-n'}</span>
0884 <span class="comment">%$        add pattern &lt;-n&gt; do NOT set option [-n]</span>
0885 <span class="comment">%$    -e    'this is'</span>
0886 <span class="comment">%$        by definition will only search for &lt;this&gt;</span>
0887 <span class="comment">%$    -e    {'this is','a test'}</span>
0888 <span class="comment">%$        will first search for &lt;this is&gt;</span>
0889 <span class="comment">%$        than &lt;a test&gt;</span>
0890 <span class="comment">%$    -s    silent mode will run much(!) faster</span>
0891 <span class="comment">%$        results can easily be extracted from P</span>
0892 <span class="comment">%$        see: &lt;grep -f&gt; for information</span>
0893 <span class="comment">%$</span>
0894 <span class="comment">%$    inclusion/exclusion of folder(s)/file(s)/full path(s)</span>
0895 <span class="comment">%$</span>
0896 <span class="comment">%$        assume this folder/file structure/contents</span>
0897 <span class="comment">%$            z:/abc/def/ghi/foo.m</span>
0898 <span class="comment">%$            z:/abc/def/ghi/foo.txt</span>
0899 <span class="comment">%$            z:/abc/def/ghi/goo.p</span>
0900 <span class="comment">%$            z:/abc/def/xxy/goo.p</span>
0901 <span class="comment">%$            z:/abc/def/xxy/goo.txt</span>
0902 <span class="comment">%$        assume this root folder when running GREP</span>
0903 <span class="comment">%$            z:/abc/def</span>
0904 <span class="comment">%$        assume the recursion flag [-r] is set</span>
0905 <span class="comment">%$</span>
0906 <span class="comment">%$    -Id    '/xx'</span>
0907 <span class="comment">%$        only searches in folder</span>
0908 <span class="comment">%$            z:/abc/def/xxy    ... all files</span>
0909 <span class="comment">%$    -Id    'xx'</span>
0910 <span class="comment">%$    -If    '\.t'    (note regular expression for &lt;.&gt;)</span>
0911 <span class="comment">%$        ***or***</span>
0912 <span class="comment">%$    -Ip    'y/g.*\.t'</span>
0913 <span class="comment">%$        only searches in folder/file</span>
0914 <span class="comment">%$            z:/abc/def/xxy/goo.txt</span>
0915 <span class="comment">%$    -Xd    '(de)|(xx)'</span>
0916 <span class="comment">%$        does not search any folder/file</span>
0917 <span class="comment">%$    -Xd    'x'</span>
0918 <span class="comment">%$        only searches in folder</span>
0919 <span class="comment">%$            z:/abc/def/ghi    ... all files</span>
0920 <span class="comment">%$    -Xd    'x'</span>
0921 <span class="comment">%$    -Xf    'txt'</span>
0922 <span class="comment">%$        only searches in folder/files</span>
0923 <span class="comment">%$            z:/abc/def/ghi/foo.m</span>
0924 <span class="comment">%$            z:/abc/def/ghi/goo.p</span>
0925 <span class="comment">%$    -Xd    'xxx'</span>
0926 <span class="comment">%$    -If    'foo'</span>
0927 <span class="comment">%$        ***or***</span>
0928 <span class="comment">%$    -Ip    'ghi/fo'</span>
0929 <span class="comment">%$        only searches in folder/files</span>
0930 <span class="comment">%$            z:/abc/def/ghi/foo.m</span>
0931 <span class="comment">%$            z:/abc/def/ghi/foo.txt</span>
0932 <span class="comment">%$</span>
0933 <span class="comment">%$    note</span>
0934 <span class="comment">%$        ALL folder separators are replaced by</span>
0935 <span class="comment">%$           unix-style &lt;/&gt; for entry checks to</span>
0936 <span class="comment">%$           facilitate the use of regular expression</span>
0937 <span class="comment">%$        leading/trailing &lt;/&gt;s are significant</span>
0938 <span class="comment">%$        inclusions and exclusions are ANDed, but single tokens</span>
0939 <span class="comment">%$           within an option are OREed for final results</span>
0940 <span class="comment">%$        multiple inclusions/exclusions may be</span>
0941 <span class="comment">%$           listed in any order</span>
0942 <span class="comment">%$        using &lt;-Ip&gt; and &lt;-Xp&gt; only may be significantly slower</span>
0943 <span class="comment">%$           compared to combinations of &lt;-I[df]&gt; and &lt;-X[df]&gt;</span>
0944 <span class="comment">%$        since folders are resolved sequentially in depth, &lt;-Xd&gt;</span>
0945 <span class="comment">%$           options will exclude any subfolder below the</span>
0946 <span class="comment">%$           excluded folder(s)</span>
0947 <span class="comment">%$</span>
0948 <span class="comment">%$  PATTERN</span>
0949 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
0950 <span class="comment">%$     'p1'        will search     &lt;p1&gt; in each FILE</span>
0951 <span class="comment">%$    {'p1',...,'pn'} will search each &lt;px&gt; in each FILE</span>
0952 <span class="comment">%$</span>
0953 <span class="comment">%$    note     'p1' cannot include white spaces</span>
0954 <span class="comment">%$        {'p1'}   may include white spaces</span>
0955 <span class="comment">%$        &lt;px&gt; may be a regular expression [-R]</span>
0956 <span class="comment">%$        only one input type will be used at runtime</span>
0957 <span class="comment">%$        precedence: 1. -f / 2. -e / 3. PATTERN</span>
0958 <span class="comment">%$</span>
0959 <span class="comment">%$  FILE</span>
0960 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
0961 <span class="comment">%$     'f1'        will search in        folder/file &lt;f1&gt;</span>
0962 <span class="comment">%$    {'f1',...,'fn'} will search in each folder/file &lt;fx&gt;</span>
0963 <span class="comment">%$</span>
0964 <span class="comment">%$    folder/file(s) are determined/expanded according to these rules</span>
0965 <span class="comment">%$</span>
0966 <span class="comment">%$    FILE        folder    file    remark</span>
0967 <span class="comment">%$    ----------------------------------------------------------</span>
0968 <span class="comment">%$    f*.x        ./    f*.x    uses current folder</span>
0969 <span class="comment">%$    /a/b        /a/b/    *.*    search all files in folder</span>
0970 <span class="comment">%$    /a/b/        /a/b/    *.*    search all files in folder</span>
0971 <span class="comment">%$    /a/b/*        /a/b/    *.*    search all files in folder</span>
0972 <span class="comment">%$    /a/b/*.x    /a/b/    *.x    search all  &lt;.x&gt; in folder</span>
0973 <span class="comment">%$    /a/b/f        /a/b/    f*.*    if &lt;f&gt; is NOT a folder</span>
0974 <span class="comment">%$    /a/b/f*.x    /a/b/    f*.x</span>
0975 <span class="comment">%$</span>
0976 <span class="comment">%$    note    if recursive folder search is selected [-r],</span>
0977 <span class="comment">%$           file(s) will be searched in the root path and</span>
0978 <span class="comment">%$           its subfolder(s)</span>
0979 <span class="comment">%$        the recursion engine does NOT use &lt;genpath&gt;</span>
0980 <span class="comment">%$        use the &lt;-I?&gt; and &lt;-X?&gt; options to use wildcard</span>
0981 <span class="comment">%$           searches on folders/files</span>
0982 <span class="comment">%$</span>
0983 <span class="comment">%$  output arguments</span>
0984 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
0985 <span class="comment">%$  FL    cell array with unique list of files with matching patterns</span>
0986 <span class="comment">%$  P    structure  with timing and result of the engines (for programmers)</span>
0987 <span class="comment">%$    see: &lt;grep -f&gt; for information about .fields</span>
0988 <span class="comment">%$___FORMAT___</span>
0989 
0990 <span class="comment">%$___OUTPUT___</span>
0991 <span class="comment">%$  SYNTAX</span>
0992 <span class="comment">%$            [FL,P] = grep(...)</span>
0993 <span class="comment">%$</span>
0994 <span class="comment">%$  output arguments</span>
0995 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
0996 <span class="comment">%$  FL          cell array with unique list of files with matching patterns</span>
0997 <span class="comment">%$  P           structure  with timings and result of the engines (for programmers)</span>
0998 <span class="comment">%$</span>
0999 <span class="comment">%$  P.fieldname:  contents              explanation</span>
1000 <span class="comment">%$  ---------------------------------------------------------------------------------</span>
1001 <span class="comment">%$        magic:  'GREP'                magic id</span>
1002 <span class="comment">%$          ver:   char                 current GREP version</span>
1003 <span class="comment">%$         mver:   char                 current ML   version</span>
1004 <span class="comment">%$      rundate:   char                 datestr(clock)</span>
1005 <span class="comment">%$      runtime:  [t1 t2 t3]            runtimes [sec]:</span>
1006 <span class="comment">%$                                      - t1: full time spent in grep</span>
1007 <span class="comment">%$                                      - t2: engine for (sub)folder(s)</span>
1008 <span class="comment">%$                                      - t3: engine for pattern matching</span>
1009 <span class="comment">%$          opt:  [struct]              current options and input args</span>
1010 <span class="comment">%$          msg:   char                 error message(s)</span>
1011 <span class="comment">%$    section_1:  '===== FOLDERS  ='    FOLDER STATS</span>
1012 <span class="comment">%$      nfolder:   double               nr of unique folder(s) found</span>
1013 <span class="comment">%$     nxfolder:   double               nr of excluded (sub)folder(s) [-Id|Xd]</span>
1014 <span class="comment">%$     nafolder:   double               nr of all (sub)folder(s)</span>
1015 <span class="comment">%$       folder:  {char}                unique folder name(s)</span>
1016 <span class="comment">%$        fenum:   double               enumerator of (sub)folder(s) in .folder</span>
1017 <span class="comment">%$                                      - subfolder(s) keep the .fenum of their root</span>
1018 <span class="comment">%$       mdepth:   double               max depth of subfolder(s)</span>
1019 <span class="comment">%$       fdepth:   double               depth of each subfolder [0: root]</span>
1020 <span class="comment">%$    section_2:  '===== PATTERNS ='    PATTERN STATS</span>
1021 <span class="comment">%$         npat:   double               nr of patterns</span>
1022 <span class="comment">%$      pattern:  {char}                pattern(s)</span>
1023 <span class="comment">%$      porigin:   char                 origin of pattern(s):</span>
1024 <span class="comment">%$                                      - 'command line'</span>
1025 <span class="comment">%$                                      -  name of pattern file [-f]</span>
1026 <span class="comment">%$    section_3:  '===== FILES    ='    FILE STATS</span>
1027 <span class="comment">%$       nfiles:   double               nr of files searched</span>
1028 <span class="comment">%$      nxfiles:   double               nr of excluded file(s)  [-If|Xf]</span>
1029 <span class="comment">%$      nafiles:   double               nr of all file(s) after [-Id|Xd]</span>
1030 <span class="comment">%$       nbytes:   double               nr of bytes read</span>
1031 <span class="comment">%$       nlines:   double               nr of lines searched</span>
1032 <span class="comment">%$    section_4:  '===== MATCHES  ='    MATCH STATS</span>
1033 <span class="comment">%$       mfiles:   double               nr of file(s) with matching patterns</span>
1034 <span class="comment">%$       mbytes:   double               nr of bytes of .mfiles file(s)</span>
1035 <span class="comment">%$       mlines:   double               nr of lines of .mfiles file(s)</span>
1036 <span class="comment">%$       pfiles:   double               nr of .files with matching patterns</span>
1037 <span class="comment">%$       pcount:   double               nr of lines with a match</span>
1038 <span class="comment">%$        files:  {char}                file name for each match</span>
1039 <span class="comment">%$                                      - repeated for each matching pattern</span>
1040 <span class="comment">%$       lcount:  [double]              count of matching lines in .files [-c]</span>
1041 <span class="comment">%$       findex:  [double]              index into .files   for each match</span>
1042 <span class="comment">%$       pindex:  [double]              index into .pattern for each match</span>
1043 <span class="comment">%$         line:  [double]              nr of matching line</span>
1044 <span class="comment">%$        match:  {char}                matching line</span>
1045 <span class="comment">%$       result:  [char]                runtime output</span>
1046 <span class="comment">%$</span>
1047 <span class="comment">%$  NOTE</span>
1048 <span class="comment">%$    to reconstruct user defined results from P, which may be useful</span>
1049 <span class="comment">%$    with the [-s] option, a programmer can use constructs like</span>
1050 <span class="comment">%$    - file name|nr counts</span>
1051 <span class="comment">%$        fmt=repmat(max(cellfun('length',P.files)),P.pfiles,1);</span>
1052 <span class="comment">%$        r=[num2cell(fmt+3),...</span>
1053 <span class="comment">%$           P.files,...</span>
1054 <span class="comment">%$           num2cell(P.lcount)].';</span>
1055 <span class="comment">%$        s=sprintf('%-*s: %5d\n',r{:})</span>
1056 <span class="comment">%$    - file name|pattern|line nr|nr counts|matching line</span>
1057 <span class="comment">%$        r=[P.files(P.findex),...</span>
1058 <span class="comment">%$           P.pattern(P.pindex),...</span>
1059 <span class="comment">%$           num2cell(P.line),...</span>
1060 <span class="comment">%$           num2cell(P.lcount(P.findex)),...</span>
1061 <span class="comment">%$           P.match]</span>
1062 <span class="comment">%$___OUTPUT___</span>
1063 
1064 <span class="comment">%$___EXAMPLE___</span>
1065 <span class="comment">% GREP EXAMPLES</span>
1066 <span class="comment">% assume GREP.TXT is in your current working folder</span>
1067     fnam=<span class="string">'grep.txt'</span>;
1068 <span class="comment">% - show contents (note all spaces are TABs!)</span>
1069     type(fnam);
1070 
1071 <span class="comment">% simple case insensitive [-i] string search in GREP.M for instances of</span>
1072 <span class="comment">%        Version</span>
1073 <span class="comment">% listing file name [def] and the line number [-n] of occurrences</span>
1074 <span class="comment">%-------------------------------------------------------------------------------</span>
1075     <a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a> -i -n Version grep.m
1076 
1077 <span class="comment">% regular expression search [-R] in GREP.M for instances of</span>
1078 <span class="comment">%        =true or =false</span>
1079 <span class="comment">% listing line number [-n] but not the file name [-Q]</span>
1080 <span class="comment">%-------------------------------------------------------------------------------</span>
1081     <a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a> -Q -n -R =true|=false grep.m
1082 
1083 <span class="comment">% simple string search in GREP.M for exactly matching [-x] instances of</span>
1084 <span class="comment">%        \t\tmsg=true;</span>
1085 <span class="comment">% listing the file name [def] and the line number [-n] for each occurrence</span>
1086 <span class="comment">%-------------------------------------------------------------------------------</span>
1087     TAB=sprintf(<span class="string">'\t'</span>);
1088     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-x -n'</span>,[TAB,TAB,<span class="string">'msg=true;'</span>],<span class="string">'grep.m'</span>);
1089 
1090 <span class="comment">% simple string search in GREP.TXT for</span>
1091 <span class="comment">%        every line of itself in turn</span>
1092 <span class="comment">% using the pattern-file [-f] option and</span>
1093 <span class="comment">% listing the full file name and pattern for each file with matches [-l]</span>
1094 <span class="comment">% as well as the file name [def] for each occurrence</span>
1095 <span class="comment">%-------------------------------------------------------------------------------</span>
1096     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-l -f'</span>,fnam,fnam);
1097 
1098 <span class="comment">% simple string search in GREP.TXT for instances of</span>
1099 <span class="comment">%        -n</span>
1100 <span class="comment">% using the [-e] option since -n itself is an option flag (listing line number!)</span>
1101 <span class="comment">% and listing the file name [def] for each non-matching line [-v] only</span>
1102 <span class="comment">% - compare with previous example!</span>
1103 <span class="comment">%-------------------------------------------------------------------------------</span>
1104     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-v -e'</span>,{<span class="string">'-n'</span>},fnam);
1105 
1106 <span class="comment">% full depth search [-r] of the entire ELFUN TOOLBOX for instances of</span>
1107 <span class="comment">%        sign or cosine or atan</span>
1108 <span class="comment">% listing the full file name and pattern for each file with matches [-l]</span>
1109 <span class="comment">% as well as the file name [def] and the line number [-n] for each occurrence</span>
1110 <span class="comment">%-------------------------------------------------------------------------------</span>
1111     fpat=[matlabroot,<span class="string">'/toolbox/matlab/elfun'</span>];
1112     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-r -l -n'</span>,{<span class="string">'sign'</span>,<span class="string">'cosine'</span>,<span class="string">'atan'</span>},fpat);
1113 
1114 <span class="comment">% full depth search [-r] of the entire ELFUN TOOLBOX for instances of</span>
1115 <span class="comment">%        sign or cosine or atan</span>
1116 <span class="comment">% using the two versions of the [-e] option and</span>
1117 <span class="comment">% listing the full file name and pattern for each file with matches [-l]</span>
1118 <span class="comment">% as well as the count [-c] of all instances</span>
1119 <span class="comment">%-------------------------------------------------------------------------------</span>
1120     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-r -l -c -e sign -e'</span>,{<span class="string">'cosine'</span>,<span class="string">'atan'</span>},fpat);
1121 
1122 <span class="comment">% full depth search [-r] of the entire ELFUN TOOLBOX for instances of</span>
1123 <span class="comment">%        sign or cosine or atan</span>
1124 <span class="comment">%    only including files with a regular expression pattern [-If]</span>
1125 <span class="comment">%        [Cc]ont</span>
1126 <span class="comment">% using the two versions of the [-e] option and</span>
1127 <span class="comment">% listing the full file name and pattern for each file with matches [-l]</span>
1128 <span class="comment">% as well as the file name [def] and the line number [-n] for each occurrence</span>
1129 <span class="comment">%-------------------------------------------------------------------------------</span>
1130     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-r -l -n -If [Cc]ont -e sign -e'</span>,{<span class="string">'cosine'</span>,<span class="string">'atan'</span>},fpat);
1131 
1132 <span class="comment">% full depth search [-r] of the entire ELFUN TOOLBOX for instances of</span>
1133 <span class="comment">%        sign or cosine or atan</span>
1134 <span class="comment">%    only including files with a regular expression pattern [-If]</span>
1135 <span class="comment">%        [Cc]ont</span>
1136 <span class="comment">%    and excluding folders with a pattern [-Xd]</span>
1137 <span class="comment">%        /ja</span>
1138 <span class="comment">% - using the two versions of the [-e] option,</span>
1139 <span class="comment">% and listing the full file name and pattern for each file with matches [-l]</span>
1140 <span class="comment">% as well as the file name [def] and the line number [-n] for each occurrence</span>
1141 <span class="comment">%-------------------------------------------------------------------------------</span>
1142     fl=<a href="grep.html" class="code" title="function    [pout,p]=grep(varargin)">grep</a>(<span class="string">'-r -l -n -If [Cc]ont -e sign -e'</span>,{<span class="string">'cosine'</span>,<span class="string">'atan'</span>},<span class="string">'-Xd'</span>,<span class="string">'/ja'</span>,fpat);
1143 <span class="comment">%$___EXAMPLE___</span>
1144 <span class="comment">%---------------------------------------------------------------------------------</span>
1145 <span class="comment">%}</span></pre></div>
<hr><address>Generated on Mon 21-May-2007 15:32:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>