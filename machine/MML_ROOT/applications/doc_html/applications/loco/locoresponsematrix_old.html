<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of locoresponsematrix_old</title>
  <meta name="keywords" content="locoresponsematrix_old">
  <meta name="description" content="LOCORESPONSEMATRIX - Calculate the BPM response matrix and dispersion function">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">applications</a> &gt; <a href="index.html">loco</a> &gt; locoresponsematrix_old.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for applications/loco&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>locoresponsematrix_old
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>LOCORESPONSEMATRIX - Calculate the BPM response matrix and dispersion function</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LOCORESPONSEMATRIX - Calculate the BPM response matrix and dispersion function
 M = LOCORESPONCEMATRIX(RINGData, BPMData, CMData)

 Accelerator Toolbox implementation of generic LOCO function

 RINGData - must have fields 'Lattice', 'CavityFrequency', 'CavityHarmNumber'
            RINGData.Lattice - AT lattice cell arrary
            RINGData.CavityFrequency  [Hz]
            RINGData.CavityHarmNumber [Hz]
 
 CMData -   must have fields: 'HCMIndex', 'VCMIndex', 'HCMKicks', 'VCMKicks', 'HCMCoupling', 'VCMCoupling'
            CMData.HCMIndex    - indexes in the AT lattice of elements used as horizontal correctors
            CMData.VCMIndex    - indexes in the AT lattice of elements used as vertical correctors
                                 Elements used as correctors in both planes should be included in both lists
            CMData.HCMKicks    - kick  size [radians] of horizontal correctors in the horizontal plane
            CMData.VCMKicks    - kick  size [radians] of vertical correctors in the vertical plane
            CMData.HCMCoupling - corrector coupling coefficient into another plane:
                                 0.01 coupling means that for 1e-3 kick in the horizontal direction there 
                                 is a 1e-5 rad kick in the vertical direction
            CMData.VCMCoupling - corrector coupling coefficient into another plane:
                                 0.01 coupling means that for 1e-3 kick in the vertical direction there 
                                 is a 1e-5 rad kick in the horizontal direction

 BPMData -  must have field 'BPMIndex'
            CMData.BPMIndex - indexes of all BPMs or observation points in the AT lattice
                              All BPS and observation points (single plane too)
                              are included in CMData.BPMIndex.

 Return value: a matrix with number of rows equal to 2*length(CMData.BPMIndex) and the number of columns
               equal length(CMData.HCMIndex)+length(CMData.VCMIndex)

 Additional string flags (in any order)
 
 LOCORESPONSEMATRIX(...,ClosedOrbitType,...)
       ClosedOrbitType is 'fixedmomentum',  'fixedpathlength' (default) 
 
 LOCORESPONCEMATRIX(..., 'linear') calculates M using linear approximation  !!! including the dispersion terms

 LOCORESPONCEMATRIX(..., 'RF', DeltaRF) - 'RF' switch must be followed by the value of DeltaRF [Hz]

 LOCORESPONCEMATRIX(..., 'ResponseMatrixMeasurement', 'oneway') - 'oneway' switch is used 
                        when the response matrix was measured only kicking the i-th corrector
                        to +KicksCoupled(i) one way, default: ResponseMatrixMeasurement = 'bidirectional'

 LOCORESPONCEMATRIX(..., 'DispersionMeasurement', 'oneway') - 'oneway' switch is used 
                        when the dispersion was measured only by varying the  
                        RF frequency in one direction, default: DispersionMeasurement = 'bidirectional'

 Or a Flags structure can be an input argument:
 LOCORESPONCEMATRIX(..., Flags)
    Flags.ResponseMatrixMeasurement = 'oneway' or {'bi-directional'}  
    Flags.DispersionMeasurement     = 'oneway' or {'bi-directional'}  
    Flags.ResponseMatrixCalculator  = {'linear'} or 'full' 
    Flags.ClosedOrbitType           = 'fixedmomentum' or {'fixedpathlength'} 

 Note: flag names are not case sensitive</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin);</a>
0002 <span class="comment">%LOCORESPONSEMATRIX - Calculate the BPM response matrix and dispersion function</span>
0003 <span class="comment">% M = LOCORESPONCEMATRIX(RINGData, BPMData, CMData)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Accelerator Toolbox implementation of generic LOCO function</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% RINGData - must have fields 'Lattice', 'CavityFrequency', 'CavityHarmNumber'</span>
0008 <span class="comment">%            RINGData.Lattice - AT lattice cell arrary</span>
0009 <span class="comment">%            RINGData.CavityFrequency  [Hz]</span>
0010 <span class="comment">%            RINGData.CavityHarmNumber [Hz]</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% CMData -   must have fields: 'HCMIndex', 'VCMIndex', 'HCMKicks', 'VCMKicks', 'HCMCoupling', 'VCMCoupling'</span>
0013 <span class="comment">%            CMData.HCMIndex    - indexes in the AT lattice of elements used as horizontal correctors</span>
0014 <span class="comment">%            CMData.VCMIndex    - indexes in the AT lattice of elements used as vertical correctors</span>
0015 <span class="comment">%                                 Elements used as correctors in both planes should be included in both lists</span>
0016 <span class="comment">%            CMData.HCMKicks    - kick  size [radians] of horizontal correctors in the horizontal plane</span>
0017 <span class="comment">%            CMData.VCMKicks    - kick  size [radians] of vertical correctors in the vertical plane</span>
0018 <span class="comment">%            CMData.HCMCoupling - corrector coupling coefficient into another plane:</span>
0019 <span class="comment">%                                 0.01 coupling means that for 1e-3 kick in the horizontal direction there</span>
0020 <span class="comment">%                                 is a 1e-5 rad kick in the vertical direction</span>
0021 <span class="comment">%            CMData.VCMCoupling - corrector coupling coefficient into another plane:</span>
0022 <span class="comment">%                                 0.01 coupling means that for 1e-3 kick in the vertical direction there</span>
0023 <span class="comment">%                                 is a 1e-5 rad kick in the horizontal direction</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% BPMData -  must have field 'BPMIndex'</span>
0026 <span class="comment">%            CMData.BPMIndex - indexes of all BPMs or observation points in the AT lattice</span>
0027 <span class="comment">%                              All BPS and observation points (single plane too)</span>
0028 <span class="comment">%                              are included in CMData.BPMIndex.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Return value: a matrix with number of rows equal to 2*length(CMData.BPMIndex) and the number of columns</span>
0031 <span class="comment">%               equal length(CMData.HCMIndex)+length(CMData.VCMIndex)</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% Additional string flags (in any order)</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% LOCORESPONSEMATRIX(...,ClosedOrbitType,...)</span>
0036 <span class="comment">%       ClosedOrbitType is 'fixedmomentum',  'fixedpathlength' (default)</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% LOCORESPONCEMATRIX(..., 'linear') calculates M using linear approximation  !!! including the dispersion terms</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% LOCORESPONCEMATRIX(..., 'RF', DeltaRF) - 'RF' switch must be followed by the value of DeltaRF [Hz]</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% LOCORESPONCEMATRIX(..., 'ResponseMatrixMeasurement', 'oneway') - 'oneway' switch is used</span>
0043 <span class="comment">%                        when the response matrix was measured only kicking the i-th corrector</span>
0044 <span class="comment">%                        to +KicksCoupled(i) one way, default: ResponseMatrixMeasurement = 'bidirectional'</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% LOCORESPONCEMATRIX(..., 'DispersionMeasurement', 'oneway') - 'oneway' switch is used</span>
0047 <span class="comment">%                        when the dispersion was measured only by varying the</span>
0048 <span class="comment">%                        RF frequency in one direction, default: DispersionMeasurement = 'bidirectional'</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Or a Flags structure can be an input argument:</span>
0051 <span class="comment">% LOCORESPONCEMATRIX(..., Flags)</span>
0052 <span class="comment">%    Flags.ResponseMatrixMeasurement = 'oneway' or {'bi-directional'}</span>
0053 <span class="comment">%    Flags.DispersionMeasurement     = 'oneway' or {'bi-directional'}</span>
0054 <span class="comment">%    Flags.ResponseMatrixCalculator  = {'linear'} or 'full'</span>
0055 <span class="comment">%    Flags.ClosedOrbitType           = 'fixedmomentum' or {'fixedpathlength'}</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% Note: flag names are not case sensitive</span>
0058 
0059 C = 2.99792458e8;
0060 
0061 <span class="comment">% Defaults</span>
0062 ResponseMatrixMeasurement = <span class="string">'bidirectional'</span>;
0063 DispersionMeasurement     = <span class="string">'bidirectional'</span>;
0064 ResponseMatrixCalculator  = <span class="string">'linear'</span>;
0065 ClosedOrbitType           = <span class="string">'fixedpathlength'</span>;
0066 
0067 RFFLAG = 0;
0068 DeltaRF = [];
0069 
0070 N = nargin-3;
0071 i = 0;
0072 <span class="keyword">while</span> i &lt; N
0073     i = i + 1;
0074     <span class="keyword">if</span> isstruct(varargin{i})
0075         Flags = varargin{i};
0076         <span class="keyword">if</span> isfield(Flags,<span class="string">'ResponseMatrixCalculator'</span>)
0077             ResponseMatrixCalculator = Flags.ResponseMatrixCalculator;
0078         <span class="keyword">end</span>
0079         <span class="keyword">if</span> isfield(Flags,<span class="string">'ClosedOrbitType'</span>)
0080             ClosedOrbitType = Flags.ClosedOrbitType;
0081         <span class="keyword">end</span>
0082         <span class="keyword">if</span> isfield(Flags,<span class="string">'ResponseMatrixMeasurement'</span>)
0083             ResponseMatrixMeasurement = Flags.ResponseMatrixMeasurement;
0084         <span class="keyword">end</span>
0085         <span class="keyword">if</span> isfield(Flags,<span class="string">'DispersionMeasurement'</span>)
0086             DispersionMeasurement = Flags.DispersionMeasurement;
0087         <span class="keyword">end</span>
0088     <span class="keyword">elseif</span> ischar(varargin{i})
0089         <span class="keyword">switch</span> lower(varargin{i})
0090             <span class="keyword">case</span> <span class="string">'linear'</span>
0091                 ResponseMatrixCalculator = <span class="string">'linear'</span>;
0092             <span class="keyword">case</span> <span class="string">'full'</span>
0093                 ResponseMatrixCalculator = <span class="string">'full'</span>;
0094             <span class="keyword">case</span> <span class="string">'fixedmomentum'</span>
0095                 ClosedOrbitType = <span class="string">'fixedmomentum'</span>;
0096             <span class="keyword">case</span> <span class="string">'fixedpathlength'</span>
0097                 ClosedOrbitType = <span class="string">'fixedpathlength'</span>;
0098             <span class="keyword">case</span> <span class="string">'rf'</span>
0099                 <span class="keyword">if</span> (i+4&lt;=nargin) &amp; isnumeric(varargin{i+1})
0100                     RFFLAG = 1;
0101                     DeltaRF = varargin{i+1};
0102                     i = i + 1;
0103                 <span class="keyword">else</span>
0104                     error(<span class="string">'''RF'' flag must be followed by a numeric value of delta RF [Hz]'</span>);
0105                 <span class="keyword">end</span>
0106             <span class="keyword">case</span> <span class="string">'dispersionmeasurement'</span>
0107                 <span class="keyword">if</span> (i+4&lt;=nargin) &amp; isstr(varargin{i+1})
0108                     DispersionMeasurement = varargin{i+1};
0109                     i = i + 1;
0110                 <span class="keyword">else</span>
0111                     error(<span class="string">'''DispersionMeasurement'' flag must be followed by ''oneway'' or ''bidirectional'''</span>);
0112                 <span class="keyword">end</span>
0113             <span class="keyword">case</span> <span class="string">'responsematrixmeasurement'</span>
0114                 <span class="keyword">if</span> (i+4&lt;=nargin) &amp; isstr(varargin{i+1})
0115                     ResponseMatrixMeasurement = varargin{i+1};
0116                     i = i + 1;
0117                 <span class="keyword">else</span>
0118                     error(<span class="string">'''ResponseMatrixMeasurement'' flag must be followed by ''oneway'' or ''bidirectional'''</span>);
0119                 <span class="keyword">end</span>
0120             <span class="keyword">otherwise</span>
0121                 warning(<span class="string">'Unknown switch ignored.'</span>);            
0122         <span class="keyword">end</span>
0123     <span class="keyword">else</span>
0124         warning(<span class="string">'Unknown switch ignored.'</span>);            
0125     <span class="keyword">end</span>
0126 <span class="keyword">end</span>
0127 
0128 
0129 <span class="comment">% Input checks</span>
0130 ResponseMatrixCalculator = lower(ResponseMatrixCalculator);
0131 ClosedOrbitType = lower(ClosedOrbitType);
0132 ResponseMatrixMeasurement = lower(ResponseMatrixMeasurement);
0133 DispersionMeasurement = lower(DispersionMeasurement);
0134 
0135 <span class="keyword">if</span> ~strcmp(ResponseMatrixMeasurement, <span class="string">'bidirectional'</span>) &amp; ~strcmp(ResponseMatrixMeasurement, <span class="string">'oneway'</span>)    
0136     error(<span class="string">'Unknown ResponseMatrixMeasurement type'</span>);
0137 <span class="keyword">end</span>
0138 <span class="keyword">if</span> ~strcmp(DispersionMeasurement, <span class="string">'bidirectional'</span>) &amp; ~strcmp(DispersionMeasurement, <span class="string">'oneway'</span>)    
0139     error(<span class="string">'Unknown DispersionMeasurement type'</span>);
0140 <span class="keyword">end</span> 
0141 <span class="keyword">if</span> ~strcmp(ResponseMatrixCalculator, <span class="string">'linear'</span>) &amp; ~strcmp(ResponseMatrixCalculator, <span class="string">'full'</span>)    
0142     error(<span class="string">'Unknown ResponseMatrixCalculator method'</span>);
0143 <span class="keyword">end</span>
0144 <span class="keyword">if</span> ~strcmp(ClosedOrbitType, <span class="string">'fixedpathlength'</span>) &amp; ~strcmp(ClosedOrbitType, <span class="string">'fixedmomentum'</span>)    
0145     error(<span class="string">'Unknown ClosedOrbitType method'</span>);
0146 <span class="keyword">end</span>
0147 
0148 
0149 <span class="comment">% Initialize</span>
0150 ATRING = RINGData.Lattice;
0151 NHC = length(CMData.HCMIndex);
0152 NVC = length(CMData.VCMIndex);
0153 NBPM = length(BPMData.BPMIndex);
0154 
0155 <span class="keyword">if</span> RFFLAG
0156     <span class="comment">% Add an extra column for the orbit responce to the RF frequency change</span>
0157     RM = zeros(2*NBPM,NHC+NVC+1); 
0158 <span class="keyword">else</span>
0159     RM = zeros(2*NBPM,NHC+NVC);
0160 <span class="keyword">end</span>
0161 
0162 
0163 NE = length(ATRING);
0164 <span class="keyword">if</span> strcmp(lower(ResponseMatrixCalculator), <span class="string">'linear'</span>)
0165     <span class="comment">% Calculate linear optics and chromatic finctions for the model</span>
0166     [M44,T,ClosedOrbit] = findm44(ATRING,0,1:NE+1);
0167     DP = 0.00001;
0168     ClosedOrbitDP = findorbit4(ATRING,DP,1:NE+1);
0169     Dispersion = (ClosedOrbitDP-ClosedOrbit)/DP;
0170     L0 = findspos(ATRING,NE+1);
0171     
0172     <span class="comment">%%X1(6)/(DP*L0); % is not the same as mcf(ATRING)???  G. Portmann</span>
0173     <span class="comment">%X1 = ringpass(ATRING,[ClosedOrbitDP(:,1);DP;0]);</span>
0174     <span class="comment">%MCF = X1(6)/(DP*L0);</span>
0175     MCF = mcf(ATRING);
0176     
0177     <span class="comment">% Transfer matrixes through individual correctors</span>
0178     M44HCOR = cell(1,NHC);
0179     M44VCOR = cell(1,NVC);  
0180     <span class="keyword">for</span> i=1:NHC
0181         M44HCOR{i}=findelemm44(ATRING{CMData.HCMIndex(i)},ATRING{CMData.HCMIndex(i)}.PassMethod,[ClosedOrbit(:,CMData.HCMIndex(i));0;0]);
0182     <span class="keyword">end</span>
0183     <span class="keyword">for</span> i=1:NVC
0184         match = find(CMData.VCMIndex(i)==CMData.HCMIndex);
0185         <span class="keyword">if</span> match
0186             M44VCOR{i}=M44HCOR{match};
0187         <span class="keyword">else</span>
0188             M44VCOR{i}=findelemm44(ATRING{CMData.VCMIndex(i)},ATRING{CMData.VCMIndex(i)}.PassMethod,[ClosedOrbit(:,CMData.VCMIndex(i));0;0]);
0189         <span class="keyword">end</span>
0190     <span class="keyword">end</span>
0191     
0192     
0193     <span class="comment">% Assemble arrays of corrector kicks including coupling</span>
0194     HCORTheta = zeros(4,NHC);
0195     VCORTheta = zeros(4,NVC); 
0196     
0197     HCORTheta(2,:) = [CMData.HCMKicks(:)]';
0198     HCORTheta(4,:) = [CMData.HCMCoupling(:)]'.*[CMData.HCMKicks(:)]';
0199     VCORTheta(2,:) = [CMData.VCMCoupling(:)]'.*[CMData.VCMKicks(:)]';
0200     VCORTheta(4,:) = [CMData.VCMKicks(:)]';
0201 
0202 
0203     <span class="comment">% Calculate closed orbit at the exit of each corrector magnet WITH applied kick</span>
0204     <span class="keyword">for</span> i=1:NHC
0205         CI = CMData.HCMIndex(i);
0206         InverseT = inv(T(:,:,CI));
0207         OrbitEntrance = (inv(eye(4)-T(:,:,CI)*M44*InverseT)*<span class="keyword">...</span>
0208             T(:,:,CI)*M44*InverseT*(eye(4)+inv(M44HCOR{i}))*HCORTheta(:,i)/2);
0209         
0210         OrbitExit = HCORTheta(:,i)/2+M44HCOR{i}*(OrbitEntrance+HCORTheta(:,i)/2);
0211         
0212         
0213         R0 = inv(T(:,:,CI+1))*OrbitExit;
0214         
0215         <span class="keyword">for</span> j=1:NBPM
0216             <span class="keyword">if</span> BPMData.BPMIndex(j)&gt;CMData.HCMIndex(i)
0217                 RM([j, j+NBPM],i) = T([1, 3],:,BPMData.BPMIndex(j))*R0;
0218                 
0219             <span class="keyword">else</span>
0220                 RM([j, j+NBPM],i) = T([1, 3],:,BPMData.BPMIndex(j))*M44*R0;
0221             <span class="keyword">end</span>
0222         <span class="keyword">end</span>
0223         
0224         <span class="keyword">if</span> strcmp(lower(ClosedOrbitType),<span class="string">'fixedpathlength'</span>)
0225             <span class="comment">% Use the average value of the dispersion at entrance and exit</span>
0226             D = HCORTheta(2,i) * <span class="keyword">...</span>
0227                 (Dispersion(1,CMData.HCMIndex(i))+Dispersion(1,CMData.HCMIndex(i)+1)) * <span class="keyword">...</span>
0228                  Dispersion([1 3],BPMData.BPMIndex) /L0/MCF/2;
0229         
0230             RM(1:NBPM,i) = RM(1:NBPM,i) - D(1,:)';
0231             RM(NBPM+1:<span class="keyword">end</span>,i) = RM(NBPM+1:<span class="keyword">end</span>,i) - D(2,:)';
0232         <span class="keyword">end</span>
0233         
0234     <span class="keyword">end</span>
0235     
0236     <span class="keyword">for</span> i=1:NVC
0237         CI = CMData.VCMIndex(i);
0238         
0239         InverseT = inv(T(:,:,CI));
0240         OrbitEntrance = (inv(eye(4)-T(:,:,CI)*M44*InverseT) * T(:,:,CI) * M44 * <span class="keyword">...</span><span class="comment"> </span>
0241             InverseT * (eye(4)+inv(M44VCOR{i}))*VCORTheta(:,i)/2);
0242         OrbitExit = VCORTheta(:,i)/2+M44VCOR{i}*(OrbitEntrance+VCORTheta(:,i)/2);
0243         
0244         R0 = inv(T(:,:,CI+1))*OrbitExit;
0245         <span class="keyword">for</span> j=1:NBPM
0246             <span class="keyword">if</span> BPMData.BPMIndex(j)&gt;CMData.VCMIndex(i)
0247                 RM([j, j+NBPM],i+NHC) = T([1, 3],:,BPMData.BPMIndex(j))*R0;
0248             <span class="keyword">else</span>
0249                 RM([j, j+NBPM],i+NHC) = T([1, 3],:,BPMData.BPMIndex(j))*M44*R0;
0250             <span class="keyword">end</span>
0251         <span class="keyword">end</span>
0252         
0253         <span class="comment">% Vertical correctors with coupling to X and non-zero horizontal dispersion</span>
0254         <span class="keyword">if</span> strcmp(lower(ClosedOrbitType),<span class="string">'fixedpathlength'</span>)
0255             <span class="comment">% Use the average value of the dispersion at entrance and exit</span>
0256             D = VCORTheta(2,i)*(Dispersion(1,CMData.VCMIndex(i))+Dispersion(1,CMData.VCMIndex(i)+1))*<span class="keyword">...</span>
0257                                 Dispersion([1 3],BPMData.BPMIndex)/L0/MCF/2;
0258             RM(1:NBPM,NHC+i) = RM(1:NBPM,NHC+i) - D(1,:)';
0259             RM(NBPM+1:<span class="keyword">end</span>,NHC+i) = RM(NBPM+1:<span class="keyword">end</span>,NHC+i) - D(2,:)';
0260         <span class="keyword">end</span>
0261     <span class="keyword">end</span>
0262     
0263     <span class="keyword">if</span> RFFLAG
0264         <span class="keyword">if</span> strcmp(lower(DispersionMeasurement), <span class="string">'bidirectional'</span>)        
0265             ORBITPLUS = findsyncorbit(RINGData.Lattice, (-C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2)/2, 1:length(RINGData.Lattice)+1);
0266             ORBIT0    = findsyncorbit(RINGData.Lattice, ( C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2)/2, 1:length(RINGData.Lattice)+1);
0267         <span class="keyword">else</span>
0268             ORBITPLUS = findsyncorbit(RINGData.Lattice, -C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2, 1:length(RINGData.Lattice)+1);
0269             ORBIT0    = findsyncorbit(RINGData.Lattice, 0, 1:length(RINGData.Lattice)+1);
0270         <span class="keyword">end</span>
0271         D = ORBITPLUS([1 3],BPMData.BPMIndex) - ORBIT0([1 3],BPMData.BPMIndex);
0272         RM(:,end) = [D(1,:)'; D(2,:)'];
0273     <span class="keyword">end</span>
0274     
0275     
0276 <span class="keyword">elseif</span> strcmp(lower(ClosedOrbitType),<span class="string">'fixedpathlength'</span>)
0277     <span class="comment">% Exact calculation using FINDSYNCORBIT</span>
0278     
0279     <span class="keyword">for</span> i = 1:NHC
0280         <span class="keyword">switch</span> ATRING{CMData.HCMIndex(i)}.PassMethod
0281         <span class="keyword">case</span> <span class="string">'CorrectorPass'</span>
0282         
0283             KickAngle0 = ATRING{CMData.HCMIndex(i)}.KickAngle;
0284             
0285             <span class="keyword">if</span> strcmp(lower(ResponseMatrixMeasurement), <span class="string">'bidirectional'</span>)        
0286                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.HCMKicks(i)/2;
0287                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.HCMKicks(i)*CMData.HCMCoupling(i)/2;
0288                 ORBITPLUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0289                 
0290                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1) - CMData.HCMKicks(i)/2;
0291                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2) - CMData.HCMKicks(i)*CMData.HCMCoupling(i)/2;
0292                 ORBITMINUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0293             <span class="keyword">else</span>
0294                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.HCMKicks(i);
0295                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.HCMKicks(i)*CMData.HCMCoupling(i);
0296                 ORBITPLUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0297                 
0298                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1);
0299                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2);
0300                 ORBITMINUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0301             <span class="keyword">end</span>
0302             
0303             ATRING{CMData.HCMIndex(i)}.KickAngle = KickAngle0;
0304             
0305             RM(:,i) = [ORBITPLUS(1,:)-ORBITMINUS(1,:),ORBITPLUS(3,:)-ORBITMINUS(3,:)]';
0306         
0307         <span class="keyword">case</span> {<span class="string">'StrMPoleSymplectic4Pass'</span>,<span class="string">'BndMPoleSymplectic4Pass'</span>}
0308             error(<span class="string">'Not implemented yet'</span>);
0309         <span class="keyword">otherwise</span>
0310             error(<span class="string">'Unknown pass method for corrector'</span>);
0311         <span class="keyword">end</span>
0312     <span class="keyword">end</span>
0313 
0314     <span class="keyword">for</span> i = 1:NVC
0315         <span class="keyword">switch</span> ATRING{CMData.VCMIndex(i)}.PassMethod
0316             <span class="keyword">case</span> <span class="string">'CorrectorPass'</span>
0317                 KickAngle0 = ATRING{CMData.VCMIndex(i)}.KickAngle;
0318                 
0319                 <span class="keyword">if</span> strcmp(lower(ResponseMatrixMeasurement), <span class="string">'bidirectional'</span>)        
0320                     ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.VCMKicks(i)/2;
0321                     ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.VCMKicks(i)*CMData.VCMCoupling(i)/2;
0322                     ORBITPLUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0323                     
0324                     ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2) - CMData.VCMKicks(i)/2;
0325                     ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1) - CMData.VCMKicks(i)*CMData.VCMCoupling(i)/2;
0326                     ORBITMINUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0327                 <span class="keyword">else</span>
0328                     ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.VCMKicks(i);
0329                     ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.VCMKicks(i)*CMData.VCMCoupling(i);
0330                     ORBITPLUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0331                     
0332                     ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2);
0333                     ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1);
0334                     ORBITMINUS = findsyncorbit(ATRING,0,BPMData.BPMIndex);
0335                 <span class="keyword">end</span>
0336                 
0337                 ATRING{CMData.VCMIndex(i)}.KickAngle = KickAngle0;
0338                 
0339                 RM(:,NHC+i) = [ORBITPLUS(1,:)-ORBITMINUS(1,:),ORBITPLUS(3,:)-ORBITMINUS(3,:)]';
0340                 
0341             <span class="keyword">case</span> {<span class="string">'StrMPoleSymplectic4Pass'</span>,<span class="string">'BndMPoleSymplectic4Pass'</span>}
0342             error(<span class="string">'Not implemented yet'</span>);
0343         <span class="keyword">otherwise</span>
0344             error(<span class="string">'Unknown pass method for corrector'</span>)
0345         <span class="keyword">end</span>
0346     <span class="keyword">end</span>
0347     
0348     <span class="keyword">if</span> RFFLAG
0349         <span class="keyword">if</span> strcmp(lower(DispersionMeasurement), <span class="string">'bidirectional'</span>)        
0350             ORBITPLUS = findsyncorbit(RINGData.Lattice, (-C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2)/2, 1:length(RINGData.Lattice)+1);
0351             ORBIT0    = findsyncorbit(RINGData.Lattice, ( C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2)/2, 1:length(RINGData.Lattice)+1);
0352         <span class="keyword">else</span>
0353             ORBITPLUS = findsyncorbit(RINGData.Lattice, -C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2, 1:length(RINGData.Lattice)+1);
0354             ORBIT0    = findsyncorbit(RINGData.Lattice, 0, 1:length(RINGData.Lattice)+1);
0355         <span class="keyword">end</span>
0356         
0357         D = ORBITPLUS([1 3],BPMData.BPMIndex) - ORBIT0([1 3],BPMData.BPMIndex);
0358         RM(:,end) = [D(1,:)';D(2,:)'];
0359     <span class="keyword">end</span>
0360     
0361 <span class="keyword">elseif</span> strcmp(lower(ClosedOrbitType),<span class="string">'fixedmomentum'</span>)
0362     <span class="comment">% ClosedOrbitType = 'fixedmomentum' - Exact calculation using FINDORBIT4</span>
0363     <span class="keyword">for</span> i = 1:NHC
0364         <span class="keyword">switch</span> ATRING{CMData.HCMIndex(i)}.PassMethod
0365         <span class="keyword">case</span> <span class="string">'CorrectorPass'</span>
0366             KickAngle0 = ATRING{CMData.HCMIndex(i)}.KickAngle;
0367             
0368             <span class="keyword">if</span> strcmp(lower(ResponseMatrixMeasurement), <span class="string">'bidirectional'</span>)        
0369                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.HCMKicks(i)/2;
0370                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.HCMKicks(i)*CMData.HCMCoupling(i)/2;
0371                 ORBITPLUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0372                 
0373                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1) - CMData.HCMKicks(i)/2;
0374                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2) - CMData.HCMKicks(i)*CMData.HCMCoupling(i)/2;
0375                 ORBITMINUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0376             <span class="keyword">else</span>
0377                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.HCMKicks(i);
0378                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.HCMKicks(i)*CMData.HCMCoupling(i);
0379                 ORBITPLUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0380                 
0381                 ATRING{CMData.HCMIndex(i)}.KickAngle(1) = KickAngle0(1);
0382                 ATRING{CMData.HCMIndex(i)}.KickAngle(2) = KickAngle0(2);
0383                 ORBITMINUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0384             <span class="keyword">end</span>
0385             
0386             ATRING{CMData.HCMIndex(i)}.KickAngle = KickAngle0;
0387         
0388             RM(:,i) = [ORBITPLUS(1,:)-ORBITMINUS(1,:),ORBITPLUS(3,:)-ORBITMINUS(3,:)]';
0389         
0390         <span class="keyword">case</span> {<span class="string">'StrMPoleSymplectic4Pass'</span>,<span class="string">'BndMPoleSymplectic4Pass'</span>}
0391             error(<span class="string">'Not implemented yet'</span>);
0392         <span class="keyword">otherwise</span>
0393             error(<span class="string">'Unknown pass method for corrector'</span>);
0394         <span class="keyword">end</span>
0395     <span class="keyword">end</span>
0396 
0397     <span class="keyword">for</span> i = 1:NVC
0398         <span class="keyword">switch</span> ATRING{CMData.HCMIndex(i)}.PassMethod
0399         <span class="keyword">case</span> <span class="string">'CorrectorPass'</span>
0400             
0401             KickAngle0 = ATRING{CMData.HCMIndex(i)}.KickAngle;
0402             
0403             <span class="keyword">if</span> strcmp(lower(ResponseMatrixMeasurement), <span class="string">'bidirectional'</span>)        
0404                 ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.VCMKicks(i)/2;
0405                 ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.VCMKicks(i)*CMData.VCMCoupling(i)/2;
0406                 ORBITPLUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0407                 
0408                 ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2) - CMData.VCMKicks(i)/2;
0409                 ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1) - CMData.VCMKicks(i)*CMData.VCMCoupling(i)/2;
0410                 ORBITMINUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0411             <span class="keyword">else</span>
0412                 ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2) + CMData.VCMKicks(i);
0413                 ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1) + CMData.VCMKicks(i)*CMData.VCMCoupling(i);
0414                 ORBITPLUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0415                 
0416                 ATRING{CMData.VCMIndex(i)}.KickAngle(2) = KickAngle0(2);
0417                 ATRING{CMData.VCMIndex(i)}.KickAngle(1) = KickAngle0(1);
0418                 ORBITMINUS = findorbit4(ATRING,0,BPMData.BPMIndex);
0419             <span class="keyword">end</span>
0420             
0421             ATRING{CMData.VCMIndex(i)}.KickAngle = KickAngle0;
0422             
0423             RM(:,NHC+i) = [ORBITPLUS(1,:)-ORBITMINUS(1,:),ORBITPLUS(3,:)-ORBITMINUS(3,:)]';
0424             
0425         <span class="keyword">case</span> {<span class="string">'StrMPoleSymplectic4Pass'</span>,<span class="string">'BndMPoleSymplectic4Pass'</span>}
0426             error(<span class="string">'Not implemented yet'</span>);
0427         <span class="keyword">otherwise</span>
0428             error(<span class="string">'Unknown pass method for corrector'</span>)
0429         <span class="keyword">end</span>
0430     <span class="keyword">end</span>
0431     
0432     <span class="keyword">if</span> RFFLAG
0433         <span class="keyword">if</span> strcmp(lower(DispersionMeasurement), <span class="string">'bidirectional'</span>)        
0434             ORBITPLUS = findsyncorbit(RINGData.Lattice, (-C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2)/2, 1:length(RINGData.Lattice)+1);
0435             ORBIT0    = findsyncorbit(RINGData.Lattice, ( C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2)/2, 1:length(RINGData.Lattice)+1);
0436         <span class="keyword">else</span>
0437             ORBITPLUS = findsyncorbit(RINGData.Lattice, -C*DeltaRF*RINGData.CavityHarmNumber/RINGData.CavityFrequency^2, 1:length(RINGData.Lattice)+1);
0438             ORBIT0    = findsyncorbit(RINGData.Lattice, 0, 1:length(RINGData.Lattice)+1);
0439         <span class="keyword">end</span>
0440         
0441         D = ORBITPLUS([1 3],BPMData.BPMIndex) - ORBIT0([1 3],BPMData.BPMIndex);
0442         RM(:,end) = [D(1,:)'; D(2,:)'];
0443     <span class="keyword">end</span>  
0444     
0445 <span class="keyword">else</span>
0446     error(<span class="string">'ClosedOrbitType method unknown'</span>);
0447 <span class="keyword">end</span>
0448</pre></div>
<hr><address>Generated on Mon 21-May-2007 15:32:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>