<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of loco</title>
  <meta name="keywords" content="loco">
  <meta name="description" content="LOCO - Main routine for the LOCO algorithm">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">applications</a> &gt; <a href="index.html">loco</a> &gt; loco.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for applications/loco&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>loco
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>LOCO - Main routine for the LOCO algorithm</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LOCO - Main routine for the LOCO algorithm

  [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData)

  See LocoManual.doc for details

  Written by Greg Portmann, James SaFranek, and Andrei Terebilo</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="locofilecheck.html" class="code" title="function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = locofilecheck(FileName)">locofilecheck</a>	LOCOFILECHECK - Consistence check for the LOCO input file</li><li><a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>	LOCOMCF - Returns the momentum compaction factor</li><li><a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>	LOCORESPONSEMATRIX - Calculate the BPM response matrix and dispersion function</li><li><a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>	LOCOSETLATTICEPARAM - Set the AT lattice from the LOCO fit parameters</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="locogui.html" class="code" title="function varargout = locogui(varargin)">locogui</a>	LOCOGUI - Graphical interface for running the LOCO algorithm</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData)</a>
0002 <span class="comment">%LOCO - Main routine for the LOCO algorithm</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%  See LocoManual.doc for details</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  Written by Greg Portmann, James SaFranek, and Andrei Terebilo</span>
0009 
0010 
0011 
0012 <span class="comment">% Note: Mmodel is in column format.</span>
0013 <span class="comment">%       Mmodel still has the outliers.  The output variable, iOutliers, tells you which ones they are (in column format).</span>
0014 
0015 
0016 <span class="comment">% Initialize</span>
0017 RMSGoal = 1e-6;           <span class="comment">% RMS change in the response matrix for parameter changes [meters]</span>
0018 RMSToleranceFactor = 10;  <span class="comment">% Lower tolerance for excepting the response matrix without recomputing (/3 for upper tolerance)</span>
0019 
0020 <span class="comment">% If NormalizationByRMSFlag, then normalize by sum(Mmodel.^2)</span>
0021 <span class="comment">%                            else normalize to keep things similar to the response matrix</span>
0022 NormalizationByRMSFlag = 0;
0023 
0024 
0025 <span class="comment">% Check inputs and add defaults</span>
0026 [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = <a href="locofilecheck.html" class="code" title="function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = locofilecheck(FileName)">locofilecheck</a>({BPMData, CMData, LocoMeasData, [], FitParameters, LocoFlags, RINGData});
0027 
0028 <span class="comment">% Fill the standard deviations with NaN so the vectors get sized properly</span>
0029 BPMData.HBPMGainSTD = NaN*ones(length(BPMData.HBPMIndex),1);
0030 BPMData.VBPMGainSTD = NaN*ones(length(BPMData.VBPMIndex),1);
0031 BPMData.HBPMCouplingSTD = NaN*ones(length(BPMData.HBPMIndex),1);
0032 BPMData.VBPMCouplingSTD = NaN*ones(length(BPMData.VBPMIndex),1);
0033 
0034 CMData.HCMKicksSTD = NaN*ones(length(CMData.HCMIndex),1);
0035 CMData.VCMKicksSTD = NaN*ones(length(CMData.VCMIndex),1);
0036 CMData.HCMCouplingSTD = NaN*ones(length(CMData.HCMIndex),1);
0037 CMData.VCMCouplingSTD = NaN*ones(length(CMData.VCMIndex),1);
0038 
0039 FitParameters.ValuesSTD = [];
0040 FitParameters.DeltaRFSTD = [];
0041 
0042 
0043 fprintf(<span class="string">'   Number of BPM:  %d horizontal %d vertical\n'</span>, length(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)), length(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)));
0044 fprintf(<span class="string">'   Number of CM:   %d horizontal %d vertical\n'</span>, length(CMData.HCMIndex(CMData.HCMGoodDataIndex)), length(CMData.VCMIndex(CMData.VCMGoodDataIndex)));
0045 
0046 
0047 <span class="comment">% Get the flags</span>
0048 LocoParams = FitParameters.Params;
0049 LocoValues = FitParameters.Values;
0050 LocoDeltas = FitParameters.Deltas;
0051 SVmethod             = LocoFlags.SVmethod;
0052 AutoCorrectDeltaFlag = LocoFlags.AutoCorrectDelta;
0053 CouplingFlag         = LocoFlags.Coupling;
0054 NormalizeFlag        = LocoFlags.Normalize;
0055 OutlierFactor        = LocoFlags.OutlierFactor;
0056 
0057 
0058 <span class="comment">% Set the lattice model to the starting LocoValues</span>
0059 <span class="keyword">for</span> i = 1:length(LocoParams)
0060     RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, LocoParams{i}, LocoValues(i));
0061 <span class="keyword">end</span>
0062 
0063 
0064 <span class="keyword">if</span> strcmpi(FitParameters.FitRFFrequency,<span class="string">'yes'</span>)
0065     <span class="keyword">if</span> strcmpi(LocoFlags.Dispersion,<span class="string">'no'</span>)
0066         LocoFlags.Dispersion = <span class="string">'Yes'</span>;
0067         fprintf(<span class="string">'   Warning:  Include dispersion flag cannot be off when fitting the RF frequency.\n'</span>);
0068         fprintf(<span class="string">'             Hence, it has been turned on.\n'</span>);
0069     <span class="keyword">end</span>
0070 <span class="keyword">end</span>
0071 
0072 <span class="comment">% BPM coupling cannot be be fit without the off-diagonal terms being included</span>
0073 <span class="keyword">if</span> strcmpi(BPMData.FitCoupling,<span class="string">'yes'</span>)
0074     <span class="keyword">if</span> strcmpi(CouplingFlag,<span class="string">'no'</span>)
0075         fprintf(<span class="string">'   Warning:  BPM coupling cannot be fit without the off-diagonal terms flag turned on.\n'</span>);
0076         fprintf(<span class="string">'             Hence, the include off-diagonal terms flag has been turned on.\n'</span>);
0077     <span class="keyword">end</span>
0078     CouplingFlag = <span class="string">'Yes'</span>;
0079     LocoFlags.Coupling = <span class="string">'Yes'</span>;
0080     <span class="comment">%BPMData.HBPMCoupling = zeros(length(BPMData.HBPMIndex),1);</span>
0081     <span class="comment">%BPMData.VBPMCoupling = zeros(length(BPMData.VBPMIndex),1);</span>
0082 <span class="keyword">end</span>
0083 
0084 <span class="comment">% CM roll cannot be be fit without the off-diagonal terms being included</span>
0085 <span class="keyword">if</span> strcmpi(CMData.FitCoupling,<span class="string">'yes'</span>)
0086     <span class="keyword">if</span> strcmpi(CouplingFlag,<span class="string">'no'</span>)
0087         fprintf(<span class="string">'   Warning:  Corrector magnets rolls cannot be fit without the off-diagonal terms flag turned on.\n'</span>);
0088         fprintf(<span class="string">'             Hence, the include off-diagonal terms flag has been turned on.\n'</span>);
0089     <span class="keyword">end</span>
0090     CouplingFlag = <span class="string">'Yes'</span>;
0091     LocoFlags.Coupling = <span class="string">'Yes'</span>;
0092     <span class="comment">%CMData.HCMCoupling = zeros(length(CMData.HCMIndex),1);</span>
0093     <span class="comment">%CMData.VCMCoupling = zeros(length(CMData.VCMIndex),1);</span>
0094 <span class="keyword">end</span>
0095 
0096 <span class="keyword">if</span> strcmpi(CMData.FitHCMEnergyShift,<span class="string">'yes'</span>) || strcmpi(CMData.FitHCMEnergyShift,<span class="string">'yes'</span>)
0097     <span class="keyword">if</span> ~strcmpi(LocoFlags.ClosedOrbitType,<span class="string">'fixedmomentum'</span>)
0098         LocoFlags.ClosedOrbitType = <span class="string">'fixedmomentum'</span>;
0099         fprintf(<span class="string">'   Warning:  When fitting energy shifts at the corrector magnets the constant\n'</span>);
0100         fprintf(<span class="string">'             momentum method must be used. Hence it has been turned on.\n'</span>);
0101     <span class="keyword">end</span>
0102 <span class="keyword">end</span>
0103 
0104 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'no'</span>) &amp;&amp; strcmpi((CMData.FitHCMEnergyShift),<span class="string">'no'</span>)
0105     <span class="keyword">if</span> ~strcmpi((LocoFlags.ClosedOrbitType),<span class="string">'fixedpathlength'</span>)
0106         <span class="comment">%LocoFlags.ClosedOrbitType = 'fixedpathlength';</span>
0107         fprintf(<span class="string">'   Warning:  When not fitting energy shifts at the corrector magnets\n'</span>);
0108         fprintf(<span class="string">'             usually the fix path length method is used.  The energy shift\n'</span>);
0109         fprintf(<span class="string">'             at the corrector magnets will still be used to adjust the model.\n'</span>);
0110     <span class="keyword">end</span>
0111 <span class="keyword">end</span>
0112 
0113 <span class="keyword">if</span> isempty(LocoMeasData.Eta) &amp;&amp; strcmpi((LocoFlags.ClosedOrbitType),<span class="string">'fixedmomentum'</span>)
0114     error(<span class="string">'Measured dispersion (LocoMeasData.Eta) can not be empty when using fixed momentum'</span>);
0115 <span class="keyword">end</span>
0116 
0117 
0118 <span class="comment">% UNITS CONVERSIONS (to be combatible with tracking code)</span>
0119 <span class="comment">% Convert corrector kicks used in the response matrix to radians</span>
0120 CMData.HCMKicks = CMData.HCMKicks(:) / 1000;   <span class="comment">% milliradian to radians (column vector)</span>
0121 CMData.VCMKicks = CMData.VCMKicks(:) / 1000;   <span class="comment">% milliradian to radians (column vector)</span>
0122 
0123 <span class="comment">% Convert the measured response matrix to meters</span>
0124 LocoMeasData.M = LocoMeasData.M / 1000;
0125 
0126 <span class="comment">% Convert the BPMSTD to meters and make the same size as a response matrix</span>
0127 LocoMeasData.BPMSTD = LocoMeasData.BPMSTD / 1000;    <span class="comment">% mm to meters</span>
0128 Mstd = LocoMeasData.BPMSTD * ones(1,size(LocoMeasData.M,2));
0129 
0130 <span class="comment">% Convert orbit for &quot;dispersion&quot; in meters in column vector format</span>
0131 LocoMeasData.Eta = LocoMeasData.Eta(:) / 1000;       <span class="comment">% mm to meters</span>
0132 <span class="comment">% END UNITS CONVERTSION</span>
0133 
0134 
0135 <span class="comment">% Pack the kicks into one vector</span>
0136 Kicks = [CMData.HCMKicks(CMData.HCMGoodDataIndex); 
0137          CMData.VCMKicks(CMData.VCMGoodDataIndex)];
0138 
0139 
0140 <span class="comment">% Use the entire family of BPMs in the model response matrix, then index later (not much difference computationally)</span>
0141 BPMIndexShortX = BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex);
0142 BPMIndexShortY = length(BPMData.BPMIndex)+BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex);
0143 BPMIndexShort = [BPMIndexShortX(:)' BPMIndexShortY(:)'];
0144 NHBPM = length(BPMData.HBPMGoodDataIndex);
0145 NVBPM = length(BPMData.VBPMGoodDataIndex);
0146 NBPM  = NHBPM + NVBPM;
0147 NHCM = length(CMData.HCMGoodDataIndex);
0148 NVCM = length(CMData.VCMGoodDataIndex);
0149 
0150 
0151 <span class="comment">% Remove unwanted data from the Mmeas and Mstd</span>
0152 Mmeas = LocoMeasData.M([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]); 
0153 Mstd  =           Mstd([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]); 
0154 
0155 <span class="comment">% If including dispersion then Mstd and Mmeas must include disperion term</span>
0156 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0157     Xstd = LocoMeasData.BPMSTD(BPMData.HBPMGoodDataIndex);
0158     Ystd = LocoMeasData.BPMSTD(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
0159     
0160     <span class="keyword">if</span> isempty(LocoMeasData.Eta)
0161         error(<span class="string">'Measured dispersion (LocoMeasData.Eta) can not be empty when including dispersion'</span>);
0162     <span class="keyword">end</span>
0163     EtaX = LocoMeasData.Eta(BPMData.HBPMGoodDataIndex);
0164     EtaY = LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
0165     
0166     LocoFlags.HorizontalDispersionWeight = abs(LocoFlags.HorizontalDispersionWeight);
0167     LocoFlags.VerticalDispersionWeight   = abs(LocoFlags.VerticalDispersionWeight);
0168 
0169     <span class="comment">% Should remove the dispersion if both weights are zero</span>
0170     <span class="keyword">if</span> LocoFlags.HorizontalDispersionWeight == 0
0171         LocoFlags.HorizontalDispersionWeight = eps;
0172     <span class="keyword">end</span>
0173     <span class="keyword">if</span> LocoFlags.VerticalDispersionWeight == 0
0174         LocoFlags.VerticalDispersionWeight = eps;
0175     <span class="keyword">end</span>
0176     
0177     <span class="comment">% Weight the dispersion</span>
0178     Mstd  = [Mstd  [Xstd/LocoFlags.HorizontalDispersionWeight; Ystd/LocoFlags.VerticalDispersionWeight]];
0179     Mmeas = [Mmeas [EtaX; EtaY]];
0180 <span class="keyword">end</span>
0181 
0182 
0183 <span class="comment">% Convert to a column vector</span>
0184 Mstd  = Mstd(:);
0185 Mmeas = Mmeas(:);
0186 
0187 
0188 <span class="comment">% Build the corrector magnet data structures to be used with locoresponsematrix</span>
0189 CMDataRM.FamName = CMData.FamName;
0190 CMDataRM.HCMIndex = CMData.HCMIndex(CMData.HCMGoodDataIndex);
0191 CMDataRM.VCMIndex = CMData.VCMIndex(CMData.VCMGoodDataIndex);
0192 CMDataRM.HCMKicks = CMData.HCMKicks(CMData.HCMGoodDataIndex);
0193 CMDataRM.VCMKicks = CMData.VCMKicks(CMData.VCMGoodDataIndex);
0194 CMDataRM.HCMCoupling = CMData.HCMCoupling(CMData.HCMGoodDataIndex);
0195 CMDataRM.VCMCoupling = CMData.VCMCoupling(CMData.VCMGoodDataIndex);
0196 CMDataRM.HCMEnergyShift = CMData.HCMEnergyShift(CMData.HCMGoodDataIndex);
0197 CMDataRM.VCMEnergyShift = CMData.VCMEnergyShift(CMData.VCMGoodDataIndex);
0198 
0199 
0200 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0201 <span class="comment">%  BUILD THE DESIGN MATRIX, A  %</span>
0202 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0203 
0204 <span class="comment">% The gradient matrix, A, is the delta response matrix w.r.t. the BPMs, corrector magnets, RF, and parameters in LocoParams</span>
0205 <span class="comment">% A = [BPMHgains BPMHcoupling BPMVcoupling BPMVgains HCMkick VCMkick HCMcoupling VCMcoupling HCMEnergyShift VCMEnergyShift RF ParamFits]</span>
0206 
0207 <span class="comment">% Find nominal response matrix</span>
0208 fprintf(<span class="string">'   Computing nominal response matrix (%s, %s) ... '</span>, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
0209 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0210     <span class="comment">% Add &quot;dispersion&quot; as a column of the response matrix</span>
0211     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
0212 <span class="keyword">else</span>
0213     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
0214 <span class="keyword">end</span>
0215 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0216 
0217 
0218 <span class="comment">% To remove the off-diagonal part of the A matrix find the index vector, iNoCoupling, of rows to keep</span>
0219 <span class="keyword">if</span> strcmpi((CouplingFlag),<span class="string">'no'</span>)
0220     CF = [ ones(NHBPM,NHCM) zeros(NHBPM,NVCM);
0221           zeros(NVBPM,NHCM)  ones(NVBPM,NVCM)];
0222 
0223     <span class="comment">% Keep the dispersion</span>
0224     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0225         <span class="comment">% Keep the horizontal and vertical part of the &quot;dispersion&quot; orbit</span>
0226         CF = [CF [2*ones(NHBPM,1); 3*ones(NVBPM,1)]];    <span class="comment">% Make zeros to ignor dispersion</span>
0227     <span class="keyword">end</span>
0228         
0229     CF = CF(:);
0230     iNoCoupling = find(CF &gt; 0);               <span class="comment">% Rows of A to keep when ignoring coupling</span>
0231     <span class="comment">%iHorizontalDispersion = find(CF == 2);   % Rows of A corresponding to horizontal dispersion</span>
0232     <span class="comment">%iVerticalDispersion = find(CF == 3);     % Rows of A corresponding to vertical dispersion</span>
0233     clear CF
0234 <span class="keyword">else</span>
0235     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0236         iNoCoupling = (1:(NVBPM+NHBPM)*(NHCM+NVCM+1))';
0237     <span class="keyword">else</span>
0238         iNoCoupling = (1:(NVBPM+NHBPM)*(NHCM+NVCM))';
0239     <span class="keyword">end</span>
0240 <span class="keyword">end</span>
0241 
0242 
0243 <span class="comment">% BPM gain and coupling</span>
0244 <span class="comment">% In order to fit the coupling term both horizontal and vertical data</span>
0245 <span class="comment">% must be available.  If there are single plane BPMs, then missing planes</span>
0246 <span class="comment">% gets removed after C * Mmodel is computed.</span>
0247 <span class="comment">% Note:  BPM gains/coupling are still used even if gains/coupling are not fitted</span>
0248 
0249 <span class="comment">% Make sure everything is a column vector</span>
0250 BPMData.HBPMGain = BPMData.HBPMGain(:);
0251 BPMData.VBPMGain = BPMData.VBPMGain(:);
0252 BPMData.HBPMCoupling = BPMData.HBPMCoupling(:);
0253 BPMData.VBPMCoupling = BPMData.VBPMCoupling(:);
0254 
0255 C11 = ones(length(BPMData.BPMIndex),1);
0256 C11(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMGain(BPMData.HBPMGoodDataIndex);
0257 
0258 C12 = zeros(length(BPMData.BPMIndex),1);
0259 C12(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex);
0260 
0261 C21 = zeros(length(BPMData.BPMIndex),1);
0262 C21(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex);
0263 
0264 C22 = ones(length(BPMData.BPMIndex),1);
0265 C22(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMGain(BPMData.VBPMGoodDataIndex);
0266 
0267 C = [diag(C11) diag(C12)
0268      diag(C21) diag(C22)];
0269 clear C11 C12 C21 C22  
0270      
0271 
0272 <span class="comment">% Pre-Allocate the A matrix - this help with memory management and time</span>
0273 numAcols = 0;
0274 NBPMfit = 0;
0275 
0276 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
0277     <span class="comment">% Horizontal BPMs Gains</span>
0278     numAcols = numAcols + NHBPM;
0279     NBPMfit  = NBPMfit  + NHBPM;
0280     <span class="comment">% Vertical BPMs Gains</span>
0281     numAcols = numAcols + NVBPM;
0282     NBPMfit  = NBPMfit  + NVBPM;
0283 <span class="keyword">end</span>   
0284 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
0285     <span class="comment">%  Horizontal coupling term</span>
0286     numAcols = numAcols + NHBPM;  
0287     NBPMfit  = NBPMfit  + NHBPM;
0288     <span class="comment">%  Vertical coupling term</span>
0289     numAcols = numAcols + NVBPM;
0290     NBPMfit  = NBPMfit  + NVBPM;
0291 <span class="keyword">end</span>
0292 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
0293     numAcols = numAcols + NHCM+NVCM;
0294 <span class="keyword">end</span>
0295 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)        
0296     numAcols = numAcols + NHCM+NVCM;
0297 <span class="keyword">end</span>
0298 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
0299     numAcols = numAcols + NHCM;
0300 <span class="keyword">end</span>
0301 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
0302     numAcols = numAcols + NVCM;
0303 <span class="keyword">end</span>
0304 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
0305     numAcols = numAcols + 1;
0306 <span class="keyword">end</span>
0307 numAcols = numAcols + length(LocoParams);
0308 
0309 <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
0310     A = zeros(length(iNoCoupling), numAcols, <span class="string">'single'</span>);
0311 <span class="keyword">else</span>
0312     A = zeros(length(iNoCoupling), numAcols);
0313 <span class="keyword">end</span>
0314 
0315 <span class="comment">% BPM fit parameters</span>
0316 <span class="comment">% Construct Abpm = [Hgains Hcoupling Vcoupling Vgains]</span>
0317 b_old = [];
0318 Acolindex = 1;
0319 
0320 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
0321     <span class="comment">% Horizontal BPMs Gains</span>
0322     <span class="keyword">for</span> i = 1:NHBPM
0323         Mdiff = [zeros(i-1,size(Mmodel,2)); Mmodel(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex(i)),:); zeros(NBPM-i,size(Mmodel,2))];
0324         Mdiff = Mdiff(:);
0325         A(:,Acolindex) = Mdiff(iNoCoupling); 
0326         Acolindex = Acolindex + 1;
0327     <span class="keyword">end</span>
0328     b_old = BPMData.HBPMGain(BPMData.HBPMGoodDataIndex);
0329     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0330 <span class="keyword">end</span>   
0331 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
0332     <span class="comment">%  Horizontal coupling term</span>
0333     <span class="keyword">for</span> i = 1:NHBPM
0334         Mdiff = [zeros(i-1,size(Mmodel,2)); Mmodel(length(BPMData.BPMIndex)+BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex(i)),:); zeros(NBPM-i,size(Mmodel,2))];
0335         Mdiff = Mdiff(:);
0336         A(:,Acolindex) = Mdiff(iNoCoupling); 
0337         Acolindex = Acolindex + 1;
0338     <span class="keyword">end</span>
0339     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0340     
0341     <span class="comment">%  Vertical coupling term</span>
0342     <span class="keyword">for</span> i = 1:NVBPM
0343         Mdiff = [zeros(NHBPM+i-1,size(Mmodel,2)); Mmodel(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex(i)),:); zeros(NVBPM-i,size(Mmodel,2))];
0344         Mdiff = Mdiff(:);
0345         A(:,Acolindex) = Mdiff(iNoCoupling); 
0346         Acolindex = Acolindex + 1;
0347     <span class="keyword">end</span>
0348     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0349     
0350     b_old = [b_old; BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex); BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex)];
0351 <span class="keyword">end</span>
0352 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
0353     <span class="comment">% Vertical BPMs Gains</span>
0354     <span class="keyword">for</span> i = 1:NVBPM
0355         Mdiff = [zeros(NHBPM+i-1,size(Mmodel,2)); Mmodel(length(BPMData.BPMIndex)+BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex(i)),:); zeros(NVBPM-i,size(Mmodel,2))];
0356         Mdiff = Mdiff(:);
0357         A(:,Acolindex) = Mdiff(iNoCoupling); 
0358         Acolindex = Acolindex + 1;
0359     <span class="keyword">end</span>
0360     b_old = [b_old; BPMData.VBPMGain(BPMData.VBPMGoodDataIndex)];    
0361     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0362 <span class="keyword">end</span>
0363 
0364 
0365 <span class="comment">% Rotate Mmodel and remove BPMs not in the measured response matrix</span>
0366 Mmodel = C * Mmodel;
0367 Mmodel = Mmodel(BPMIndexShort, :); 
0368 
0369 
0370 <span class="comment">% Compute corrector gain response matrix, Acor</span>
0371 NormalizationFactCM = [];
0372 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
0373     
0374     <span class="comment">% Compute Acor by scaling Mmodel (don't include dispersion)</span>
0375     Acor = zeros(NBPM*(NHCM+NVCM),NHCM+NVCM);
0376     <span class="keyword">for</span> i=1:NHCM+NVCM
0377         Acor((i-1)*NBPM+(1:NBPM),i) = Mmodel(:,i) / Kicks(i);
0378     <span class="keyword">end</span>
0379     
0380     <span class="comment">% Assume that the change in dispersion due to a corrector magnet is zero</span>
0381     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0382         Acor = [Acor; zeros(NBPM,NHCM+NVCM)];
0383     <span class="keyword">end</span>
0384     
0385     NormalizationFactCM = 1 ./ Kicks;
0386     b_old = [b_old; Kicks];
0387     A(:,Acolindex:(Acolindex+NHCM+NVCM-1)) = Acor(iNoCoupling,:); 
0388     
0389     Acolindex = Acolindex + NHCM+NVCM;
0390     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0391 <span class="keyword">end</span>
0392 
0393 
0394 <span class="comment">% Compute corrector coupling response matrix</span>
0395 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)        
0396     <span class="comment">% Compute Acor numerically</span>
0397     CMCouplingDeltas = 1e-6;    <span class="comment">% Coupling size should be based a computer round off error ???</span>
0398     CMDataRM.HCMCoupling = CMDataRM.HCMCoupling + CMCouplingDeltas * ones(length(CMDataRM.HCMCoupling),1); 
0399     CMDataRM.VCMCoupling = CMDataRM.VCMCoupling + CMCouplingDeltas * ones(length(CMDataRM.VCMCoupling),1); 
0400     
0401     fprintf(<span class="string">'   Computing nominal response matrix for a change in corrector magnet coupling (%s, %s) ... '</span>, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
0402     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0403         <span class="comment">% Add &quot;dispersion&quot; as a column of the response matrix</span>
0404         GR = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
0405     <span class="keyword">else</span>
0406         GR = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
0407     <span class="keyword">end</span>
0408     fprintf(<span class="string">'%f seconds. \n'</span>, toc);
0409         
0410     <span class="comment">% Rotate by the BPM gain, roll, crunch</span>
0411     GR = C * GR;
0412     
0413     <span class="comment">% Remove BPMs not in the response matrix</span>
0414     GR = GR(BPMIndexShort, :); 
0415         
0416     Acor = zeros(NBPM*(NHCM+NVCM),NHCM+NVCM);
0417     <span class="keyword">for</span> i=1:NHCM+NVCM
0418         Acor((i-1)*NBPM+(1:NBPM),i) = (GR(:,i)-Mmodel(:,i)) / CMCouplingDeltas;
0419     <span class="keyword">end</span>
0420     
0421     <span class="comment">% Assume that the change in dispersion due to a corrector magnet is zero</span>
0422     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0423         Acor = [Acor; zeros(NBPM,NHCM+NVCM)];
0424     <span class="keyword">end</span>
0425     
0426     <span class="comment">% Return the coupling vectors back to normal</span>
0427     CMDataRM.HCMCoupling = CMDataRM.HCMCoupling - CMCouplingDeltas * ones(length(CMDataRM.HCMCoupling),1); 
0428     CMDataRM.VCMCoupling = CMDataRM.VCMCoupling - CMCouplingDeltas * ones(length(CMDataRM.VCMCoupling),1); 
0429     
0430     A(:,Acolindex:(Acolindex+NHCM+NVCM-1)) = Acor(iNoCoupling,:);     
0431     Acolindex = Acolindex+NHCM+NVCM;
0432     b_old = [b_old; CMDataRM.HCMCoupling; CMDataRM.VCMCoupling];
0433     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0434 <span class="keyword">end</span>
0435 
0436 
0437 <span class="comment">% Fit the energy shift at the corrector magnets</span>
0438 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
0439     
0440     AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
0441     EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0442     EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0443     
0444     <span class="comment">% Compute Acor from the measured dispersion</span>
0445     Acor = zeros(NBPM*(NHCM+NVCM), NHCM);
0446     <span class="keyword">for</span> i = 1:NHCM
0447         Acor((i-1)*NBPM+(1:NHBPM), i) = EtaXmcf;
0448 
0449         <span class="comment">% Plus the coupling term to the vertical plane</span>
0450         Acor((i-1)*NBPM+NHBPM+(1:NVBPM), i) = EtaYmcf;      
0451         <span class="comment">%Acor((i-1)*NBPM+NHBPM+(1:NVBPM), i) = CMDataRM.HCMCoupling(i) * EtaYmcf;</span>
0452         <span class="comment">%Acor((i-1)*NBPM+NHBPM+(1:NVBPM), i) = zeros(size(EtaYmcf));</span>
0453     <span class="keyword">end</span>
0454     
0455     <span class="comment">% Assume that the change in dispersion due to a energy shift is zero</span>
0456     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0457         Acor = [Acor; zeros(NBPM,NHCM)];
0458     <span class="keyword">end</span>
0459     
0460     NormalizationFactHCMEnergy = abs(AlphaMCF * LocoMeasData.RF / LocoMeasData.DeltaRF);
0461     A(:,Acolindex:(Acolindex+NHCM-1)) = Acor(iNoCoupling,:); 
0462     Acolindex = Acolindex + NHCM;
0463     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0464     b_old = [b_old; CMDataRM.HCMEnergyShift;];
0465 <span class="keyword">else</span>
0466     NormalizationFactHCMEnergy = [];
0467 <span class="keyword">end</span>
0468 
0469 
0470 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
0471     
0472     <span class="keyword">if</span> ~exist(<span class="string">'AlphaMCF'</span>)
0473         AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
0474         EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0475         EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0476     <span class="keyword">end</span>
0477     
0478     <span class="comment">% Compute Acor from the measured dispersion</span>
0479     Acor = zeros(NBPM*(NHCM+NVCM), NVCM);
0480     <span class="keyword">for</span> i = 1:NVCM
0481         Acor((NHCM+i-1)*NBPM+NHBPM+(1:NVBPM), i) = EtaYmcf;
0482         
0483         <span class="comment">% Plus the coupling term to the horizontal plane</span>
0484         Acor((NHCM+i-1)*NBPM+(1:NHBPM), i) = EtaXmcf;        
0485         
0486         <span class="comment">%Acor((i-1)*NBPM+(1:NHBPM), i) = CMDataRM.VCMCoupling(i) * EtaXmcf;</span>
0487         <span class="comment">%Acor((i-1)*NBPM+(1:NHBPM), i) = zeros(size(EtaXmcf));</span>
0488     <span class="keyword">end</span>
0489     
0490     <span class="comment">% Assume that the change in dispersion due to a energy shift is zero</span>
0491     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0492         Acor = [Acor; zeros(NBPM,NVCM)];
0493     <span class="keyword">end</span>
0494 
0495     NormalizationFactVCMEnergy = abs(AlphaMCF * LocoMeasData.RF / LocoMeasData.DeltaRF);
0496     A(:,Acolindex:(Acolindex+NVCM-1)) = Acor(iNoCoupling,:); 
0497     Acolindex = Acolindex + NVCM;
0498     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0499     b_old = [b_old; CMDataRM.VCMEnergyShift];
0500 <span class="keyword">else</span>
0501     NormalizationFactVCMEnergy = [];
0502 <span class="keyword">end</span>
0503 
0504 clear Acor
0505 
0506 
0507 <span class="comment">% Include RF Frequency as a parameter</span>
0508 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
0509     <span class="comment">% A weighted and rotated &quot;Disperion&quot; is stored in the last column of Mmodel (change in orbit due to change in RF frequency and rotate by the BPM gain, roll, crunch)</span>
0510     Mrf = [zeros(NBPM,NHCM+NVCM) Mmodel(:,end)/FitParameters.DeltaRF];
0511     Mrf = Mrf(:);
0512     
0513     <span class="comment">% Include in the A matrix</span>
0514     A(:,Acolindex) = Mrf(iNoCoupling); 
0515     Acolindex = Acolindex + 1;
0516     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0517     b_old = [b_old; FitParameters.DeltaRF];
0518 <span class="keyword">end</span>
0519 
0520 
0521 <span class="comment">% Compute response matrix for the rest of the parameters</span>
0522 LocoValues = LocoValues(:);      <span class="comment">% Force a column vector</span>
0523 <span class="keyword">for</span> i = 1:length(LocoParams)
0524     <span class="comment">% Find the correct delta to use:</span>
0525     <span class="comment">% If AutoCorrectDeltaFlag = 'yes', then correct the delta on every iteration and recompute</span>
0526     <span class="comment">%                                  if outside the RMSGoal/RMSToleranceFactor or RMSGoal*RMSToleranceFactor/3</span>
0527     <span class="comment">% If AutoCorrectDeltaFlag = 'no', then the user input will be used (unless it's NaN).</span>
0528     <span class="comment">% If LocoDeltas = NaN, then guess a value of .1% of LocoValues and test using the RMSGoal check.</span>
0529     DeltaCheckFlag = 1;
0530     <span class="keyword">while</span> DeltaCheckFlag
0531         <span class="comment">% If a delta is not given, then set it to .1% of the value and check that it is OK</span>
0532         <span class="keyword">if</span> isnan(LocoDeltas(i))
0533             LocoDeltas(i) = .001 * LocoValues(i);
0534             <span class="keyword">if</span> LocoDeltas(i) == 0
0535                 LocoDeltas(i) = 1e-6;     <span class="comment">% You just have to guess something and have it auto-correct</span>
0536             <span class="keyword">end</span>
0537             OneTimeAutoCorrect = <span class="string">'yes'</span>;   <span class="comment">% In case auto correction is not on</span>
0538         <span class="keyword">else</span>
0539             OneTimeAutoCorrect = <span class="string">'no'</span>;
0540         <span class="keyword">end</span>
0541         
0542         
0543         <span class="comment">% Compute the response matrix with the parameter change</span>
0544         RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, LocoParams{i}, LocoValues(i)+LocoDeltas(i));
0545         
0546         fprintf(<span class="string">'   Parameter #%d, Computing response matrix (%s, %s) ... '</span>, i, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
0547         <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0548             <span class="comment">% Add &quot;dispersion&quot; as a column of the response matrix</span>
0549             Mparam = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
0550         <span class="keyword">else</span>
0551             Mparam = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
0552         <span class="keyword">end</span>
0553         fprintf(<span class="string">'%f seconds. \n'</span>, toc);
0554         
0555         
0556         <span class="comment">% Rotate by the BPM gain, roll, crunch</span>
0557         Mparam = C * Mparam;
0558         
0559         <span class="comment">% Remove BPMs not in the response matrix</span>
0560         Mparam = Mparam(BPMIndexShort, :); 
0561                 
0562         <span class="comment">% Response matrix gradient</span>
0563         Mdiff = Mparam - Mmodel;
0564         Mdiff = Mdiff(:);
0565 
0566         <span class="comment">% Compute rms response matrix change (ignor weighted dispersion)</span>
0567         <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0568             Mdiff_nodispersion = Mparam(:,1:end-1) - Mmodel(:,1:end-1);
0569             Mdiff_nodispersion = Mdiff_nodispersion(:);
0570             RMSDelta = sqrt(sum(Mdiff_nodispersion.^2)/length(Mdiff_nodispersion));
0571             clear Mdiff_nodispersion
0572         <span class="keyword">else</span>
0573             RMSDelta = sqrt(sum(Mdiff.^2)/length(Mdiff));
0574         <span class="keyword">end</span>
0575 
0576         <span class="comment">% If the RMSDelta is inf, just error (not good, not fixable)</span>
0577         <span class="keyword">if</span> isinf(RMSDelta)
0578             fprintf(<span class="string">'   Parameter #%d, RMS(Model(Delta=%0.5g)-Model(0))=%0.5g mm\n'</span>, i, LocoDeltas(i), 1000*RMSDelta);
0579             error(<span class="string">'LOCO error:  RMS difference must be finite'</span>);
0580         <span class="keyword">end</span>
0581         
0582         <span class="comment">% Save the delta used to compute the response matrix (this might be a little confusing since the new LocoDeltas</span>
0583         <span class="comment">% may not be the same as the one used to compute the response matrix due to the auto correction algorithm).</span>
0584         Delta = LocoDeltas(i);
0585         
0586         <span class="keyword">if</span> strcmpi((AutoCorrectDeltaFlag),<span class="string">'yes'</span>) || strcmpi((OneTimeAutoCorrect),<span class="string">'yes'</span>)
0587             <span class="keyword">if</span> RMSDelta &lt; RMSGoal/RMSToleranceFactor
0588                 <span class="comment">% Delta too small, recompute</span>
0589                 fprintf(<span class="string">'   Parameter #%d, Response matrix delta too small, RMS(Model(%0.5g)-Model(%0.5g))=%0.5g mm\n'</span>, i, LocoValues(i)+LocoDeltas(i), LocoValues(i), 1000*RMSDelta);
0590                 LocoDeltas(i) = LocoDeltas(i) * RMSGoal / RMSDelta;   
0591             <span class="keyword">elseif</span> RMSDelta &gt; RMSGoal*RMSToleranceFactor/3
0592                 <span class="comment">% Delta too large, recompute</span>
0593                 fprintf(<span class="string">'   Parameter #%d, Response matrix delta too big, RMS(Model(%0.5g)-Model(%0.5g))=%0.5g mm\n'</span>, i, LocoValues(i)+LocoDeltas(i), LocoValues(i), 1000*RMSDelta);
0594                 LocoDeltas(i) = LocoDeltas(i) * RMSGoal / RMSDelta;
0595             <span class="keyword">else</span>
0596                 <span class="comment">% Use the response matrix but correct the delta</span>
0597                 fprintf(<span class="string">'   Parameter #%d, Response matrix delta OK, RMS(Model(%0.5g)-Model(%0.5g))=%0.5g mm\n'</span>, i, LocoValues(i)+LocoDeltas(i), LocoValues(i), 1000*RMSDelta);
0598                 LocoDeltas(i) = LocoDeltas(i) * RMSGoal / RMSDelta;
0599                 fprintf(<span class="string">'   Parameter #%d, Autocorrection of delta,  the  new  Delta=%f\n'</span>, i, LocoDeltas(i));
0600                 DeltaCheckFlag = 0;
0601             <span class="keyword">end</span>
0602         <span class="keyword">else</span>
0603             <span class="comment">% Autocorrect delta off, warn if too big or small</span>
0604             DeltaCheckFlag = 0;
0605             <span class="keyword">if</span> RMSDelta &lt; RMSGoal/RMSToleranceFactor
0606                 <span class="comment">% Delta is small</span>
0607                 fprintf(<span class="string">'   WARNING:  Parameter #%d, Delta for response matrix is small, RMS(Model(Delta=%0.5g)-Model(Nominal))=%f mm.\n'</span>, i, LocoDeltas(i), 1000*RMSDelta);
0608             <span class="keyword">elseif</span> RMSDelta &gt; RMSGoal*RMSToleranceFactor/3
0609                 <span class="comment">% Delta is large</span>
0610                 fprintf(<span class="string">'   WARNING:  Parameter #%d, Delta for response matrix is large, RMS(Model(Delta=%0.5g)-Model(Nominal))=%f mm.\n'</span>, i, LocoDeltas(i), 1000*RMSDelta);
0611             <span class="keyword">end</span>
0612         <span class="keyword">end</span>
0613     <span class="keyword">end</span>
0614     
0615     
0616     <span class="comment">% Restore the nominal setpoint</span>
0617     RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, LocoParams{i}, LocoValues(i));
0618 
0619     <span class="comment">% Include in the A matrix</span>
0620     A(:,Acolindex) = Mdiff(iNoCoupling)/Delta; 
0621     Acolindex = Acolindex + 1;
0622     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
0623     
0624     b_old = [b_old; LocoValues(i)];
0625     
0626 <span class="keyword">end</span>
0627 
0628 
0629 <span class="comment">% When using the fixed momentum response matrix calculator, the merit function becomes:</span>
0630 <span class="comment">%              Merit = Mmeas_ij - Mmod_ij - Dp/p_j * eta_i</span>
0631 <span class="comment">%              where eta_i is the measured eta (not the model eta)</span>
0632 <span class="comment">% This is done by changing Mmodel to (Mmodel_ij + Dp/p_j * eta_i)</span>
0633 <span class="comment">%if strcmpi((CMData.FitHCMEnergyShift),'yes') | strcmpi((CMData.FitVCMEnergyShift),'yes')</span>
0634 <span class="keyword">if</span> strcmpi((LocoFlags.ClosedOrbitType), <span class="string">'fixedmomentum'</span>)
0635     HCMEnergyShift = CMData.HCMEnergyShift(CMData.HCMGoodDataIndex);
0636     VCMEnergyShift = CMData.VCMEnergyShift(CMData.VCMGoodDataIndex);
0637     
0638     <span class="comment">%Mmodel = reshape(Mmodel,NHBPM+NVBPM,NHCM+NVCM);</span>
0639     
0640     <span class="keyword">if</span> ~exist(<span class="string">'AlphaMCF'</span>)
0641         AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
0642         EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0643         EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0644     <span class="keyword">end</span>
0645 
0646     <span class="keyword">for</span> i = 1:length(HCMEnergyShift)
0647         Mmodel(:,i) = Mmodel(:,i) + HCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
0648     <span class="keyword">end</span>
0649     
0650     <span class="keyword">for</span> i = 1:length(VCMEnergyShift)
0651         Mmodel(:,NHCM+i) = Mmodel(:,NHCM+i) + VCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
0652     <span class="keyword">end</span>
0653 <span class="keyword">end</span>
0654 
0655 
0656 <span class="comment">% Column vectorize the model</span>
0657 Mmodel = Mmodel(:);
0658 
0659 
0660 <span class="comment">% Remove coupling rows</span>
0661 <span class="keyword">if</span> strcmpi((CouplingFlag),<span class="string">'no'</span>)
0662     Mmodel = Mmodel(iNoCoupling,:); 
0663     Mmeas = Mmeas(iNoCoupling,:); 
0664     Mstd = Mstd(iNoCoupling,:); 
0665 <span class="keyword">end</span>
0666 
0667 
0668 
0669 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0670 <span class="comment">%  LEAST SQUARES (SVD) MINIMIZATION %</span>
0671 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0672 <span class="comment">%</span>
0673 <span class="comment">% min | A*b - (Mmeas - Mmodel) |</span>
0674 <span class="comment">%  b</span>
0675 <span class="comment">%</span>
0676 <span class="comment">% Note 1: ChiSquare has the outliers removed.</span>
0677 <span class="comment">% Note 2: ChiSquareVector is only computed if the user requests it with SVmethod=[] (interactive).</span>
0678 
0679 
0680 <span class="comment">% Weighted LS</span>
0681 <span class="comment">% Since BPM errors can be heteroscedastic, weighted LS is used.</span>
0682 <span class="comment">% W*(Mmeas - Mmodel) = W*A*b + W*e,  where the e's are gausian, zero mean, independent, but not constant variance</span>
0683 <span class="comment">% W is chosen to make E(Wee'W') = sigma * I  (ie, W * e has a constant variance)</span>
0684 <span class="comment">%</span>
0685 <span class="comment">% The new LS equations are,</span>
0686 <span class="comment">% b = inv(Amod'*W'*W*Amod)*Amod'*W'*W*(Mmeas - Mmodel);      % Parameter fit</span>
0687 <span class="comment">% b = V(:,Ivec) * b;</span>
0688 <span class="comment">% bvar = inv(Amod'*W'*W*Amod);</span>
0689 <span class="comment">%</span>
0690 <span class="comment">% Since the weight matrix, W, is only going to be diagonal, it is less memory</span>
0691 <span class="comment">% to scaled Amod and (Mmeas-Model) by the diagonal term and not create the matrix W</span>
0692 <span class="keyword">for</span> i = 1:length(Mstd)
0693     A(i,:) = A(i,:) / Mstd(i);
0694 <span class="keyword">end</span>
0695 
0696 
0697 <span class="comment">% Look for outliers in Mmeas</span>
0698 <span class="comment">% Remove row from A, Mmeas, Mmodel if any element of Mmeas-Mmodel is greater than OutlierFactor time the std(Mmeas-Mmodel).</span>
0699 <span class="comment">% The test is done twice in case an outlier is very large and can affect the mean and std.</span>
0700 <span class="comment">%y = Mmeas;             % All points in the measurement shouldn't be too far from the std (this does not work for dispersion)</span>
0701 y = Mmeas - Mmodel;     <span class="comment">% If the model is far off from the measurement, this could be a problem (make the OutlierFactor large)</span>
0702 
0703 <span class="comment">% % Note: dispersion error should be scaled by the weight (maybe this should be made a separate outlier test)</span>
0704 <span class="comment">% % Remove the weight on the dispersion for the outlier calculation</span>
0705 <span class="comment">% if strcmpi((LocoFlags.Dispersion),'yes')</span>
0706 <span class="comment">%     % Horizontal and vertical dispersion were added to the response matrix</span>
0707 <span class="comment">%     WeightedEta = y(end-NBPM+1:end);</span>
0708 <span class="comment">%     UnWeightedEtaX = WeightedEta(1:NHBPM) * LocoFlags.HorizontalDispersionWeight;</span>
0709 <span class="comment">%     UnWeightedEtaY = WeightedEta(NHBPM+(1:NVBPM)) * LocoFlags.VerticalDispersionWeight;</span>
0710 <span class="comment">%     y(end-NBPM+1:end) = [UnWeightedEtaX; UnWeightedEtaY];</span>
0711 <span class="comment">% end</span>
0712 
0713 i1 = find(abs(y-mean(y)) &gt;  OutlierFactor*std(y));             <span class="comment">% Index of bad  data points, first  test</span>
0714 j1 = find(abs(y-mean(y)) &lt;= OutlierFactor*std(y));             <span class="comment">% Index of good data points, first  test</span>
0715 i2 = find(abs(y(j1)-mean(y(j1))) &gt; OutlierFactor*std(y(j1)));  <span class="comment">% Index of bad  data points, second test</span>
0716 iOutliers = sort([i1; j1(i2)]);
0717 
0718 <span class="keyword">if</span> isempty(iOutliers)
0719     fprintf(<span class="string">'   No outliers in the data set.\n'</span>);
0720 <span class="keyword">else</span>
0721     fprintf(<span class="string">'   std(Model-Measurement) = %f mm (with outliers)\n'</span>, 1000*std(Mmeas-Mmodel));
0722     A(iOutliers,:)      = [];
0723     Mmeas(iOutliers,:)  = [];
0724     Mmodel(iOutliers,:) = [];
0725     Mstd(iOutliers,:)   = [];
0726     fprintf(<span class="string">'   %d outliers removed out of %d points (&gt; %d sigma) (%d first test + %d second test).\n'</span>, length(iOutliers), length(y), OutlierFactor, length(i1), length(j1(i2)));
0727 <span class="keyword">end</span>
0728 fprintf(<span class="string">'   std(Model-Measurement) = %f mm\n'</span>, 1000*std(Mmeas-Mmodel));
0729 
0730 
0731 <span class="comment">% Normalize A  (which can be thought of as a change in units of the parameters)</span>
0732 <span class="comment">% Force the square sum of the column of A for parameter fits to that of Mmodel</span>
0733 <span class="comment">% Divid the CMs by the kick</span>
0734 <span class="comment">% A = [BPMHgains BPMHcoupling BPMVcoupling BPMVgains HCMkick VCMkick HCMcoupling VCMcoupling HCMEnergyShift VCMEnergyShift RF ParamFits]</span>
0735 Mmodelsq = sum((Mmodel./Mstd).^2);  <span class="comment">%sum(Mmodel.^2);</span>
0736 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
0737     <span class="comment">% Always normalize the RF frequency fit</span>
0738     <span class="comment">%NormalizationFactRF = sqrt(sum(A(:,end-length(LocoParams):end-length(LocoParams)).^2) / Mmodelsq)';</span>
0739     NormalizationFactRF = 1 / FitParameters.DeltaRF / 10;    <span class="comment">% Extra weighted just to get a better fit</span>
0740     A(:,end-length(LocoParams)) = A(:,end-length(LocoParams)) / NormalizationFactRF;
0741 <span class="keyword">else</span>
0742     NormalizationFactRF = [];
0743 <span class="keyword">end</span>
0744 
0745 NormalizationFact = [];
0746 <span class="keyword">if</span> strcmpi((NormalizeFlag),<span class="string">'yes'</span>)
0747     <span class="keyword">if</span> NormalizationByRMSFlag        
0748         <span class="comment">% Entire A matrix</span>
0749         <span class="comment">% Note: the RF freq will get normalized twice but that's OK</span>
0750         NormalizationFact = sqrt(sum(A.^2) / Mmodelsq)';
0751         <span class="keyword">for</span> i = 1:length(NormalizationFact)
0752             A(:,i) = A(:,i) / NormalizationFact(i);
0753         <span class="keyword">end</span>
0754         
0755         <span class="comment">%% Just the parameter fits</span>
0756         <span class="comment">%if length(LocoParams) ~= 0</span>
0757         <span class="comment">%    NormalizationFact = sqrt(sum(A(:,end-length(LocoParams)+1:end).^2) / Mmodelsq)';</span>
0758         <span class="comment">%    for i = 1:length(LocoParams)</span>
0759         <span class="comment">%        A(:,i+end-length(LocoParams)) = A(:,i+end-length(LocoParams)) / NormalizationFact(i);</span>
0760         <span class="comment">%    end</span>
0761         <span class="comment">%end</span>
0762     <span class="keyword">else</span>
0763         <span class="comment">% BPMs do not need a normalization factor</span>
0764         
0765         <span class="comment">% Corrector magnets</span>
0766         <span class="keyword">if</span> ~isempty(NormalizationFactCM)
0767             <span class="keyword">for</span> i = 1:length(NormalizationFactCM)
0768                 A(:,i+NBPMfit) = A(:,i+NBPMfit) / NormalizationFactCM(i);
0769             <span class="keyword">end</span>       
0770         <span class="keyword">end</span>
0771         <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)    
0772             NN = length(NormalizationFactCM);
0773             <span class="keyword">for</span> i = 1:NHCM+NVCM
0774                 NormalizationFactCM(NN+i,1) = sqrt(sum(A(:,NBPMfit+NN+i).^2) / Mmodelsq);
0775                 A(:,i+NBPMfit+NN) = A(:,i+NBPMfit+NN) / NormalizationFactCM(NN+i);
0776             <span class="keyword">end</span>
0777         <span class="keyword">end</span>
0778         <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
0779             <span class="comment">%NN = length(NormalizationFactCM);</span>
0780             <span class="comment">%for i = 1:NHCM</span>
0781             <span class="comment">%    NormalizationFactCM(NN+i) = sqrt(sum(A(:,NBPMfit+NN+i).^2) / Mmodelsq);</span>
0782             <span class="comment">%    A(:,i+NBPMfit+NN) = A(:,i+NBPMfit+NN) / NormalizationFactCM(NN+i);</span>
0783             <span class="comment">%end</span>
0784             NN = NBPMfit + length(NormalizationFactCM);
0785             A(:,NN+1:NN+NHCM) = A(:,NN+1:NN+NHCM) / NormalizationFactHCMEnergy;
0786         <span class="keyword">end</span>
0787         <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
0788             <span class="comment">%NN = length(NormalizationFactCM);</span>
0789             <span class="comment">%for i = 1:NVCM</span>
0790             <span class="comment">%    NormalizationFactCM(NN+i) = sqrt(sum(A(:,NBPMfit+NN+i).^2) / Mmodelsq);</span>
0791             <span class="comment">%    A(:,i+NBPMfit+NN) = A(:,i+NBPMfit+NN) / NormalizationFactCM(NN+i);</span>
0792             <span class="comment">%end</span>
0793             NN = NBPMfit + length(NormalizationFactCM) + NHCM;
0794             A(:,NN+1:NN+NVCM) = A(:,NN+1:NN+NVCM) / NormalizationFactVCMEnergy;
0795         <span class="keyword">end</span>
0796         
0797         <span class="comment">% Parameter fits</span>
0798         <span class="keyword">if</span> ~isempty(LocoParams)
0799             NormalizationFact = sqrt(sum(A(:,end-length(LocoParams)+1:end).^2) / Mmodelsq)';
0800             <span class="keyword">for</span> i = 1:length(LocoParams)
0801                 A(:,i+end-length(LocoParams)) = A(:,i+end-length(LocoParams)) / NormalizationFact(i);
0802             <span class="keyword">end</span>
0803         <span class="keyword">end</span>
0804     <span class="keyword">end</span>
0805 <span class="keyword">end</span>
0806 
0807 
0808 
0809 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0810 <span class="comment">% Include a cost function by adding rows to the Jacobian matrix A and response vector y %</span>
0811 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0812 <span class="keyword">if</span> isfield(FitParameters, <span class="string">'Weight'</span>)
0813     <span class="comment">% Partition a zero matrix of weight</span>
0814     NumFitPara = length(FitParameters.Values);
0815     NumWeight  = length(FitParameters.Weight.Index);
0816     Arows = size(A,1);
0817     A = [A; zeros(NumWeight, size(A,2))];
0818 
0819     <span class="comment">% Add the weights</span>
0820     MeanMstd = mean(Mstd);
0821     <span class="keyword">for</span> ii = 1:NumWeight
0822         A(Arows+ii, end-NumFitPara+FitParameters.Weight.Index{ii}) = FitParameters.Weight.Value{ii} / MeanMstd;
0823     <span class="keyword">end</span>
0824 <span class="keyword">end</span>
0825 
0826 
0827 <span class="comment">% Compute S and select the singular vectors</span>
0828 <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
0829     fprintf(<span class="string">'   Computing SVD (single precision) ... '</span>); tic
0830     A = single(A);
0831 <span class="keyword">else</span>
0832     fprintf(<span class="string">'   Computing SVD ... '</span>); tic
0833 <span class="keyword">end</span>
0834 [U, S, V] = svd(A,0);
0835 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0836 
0837 
0838 <span class="comment">% Save data if requested by the user</span>
0839 <span class="comment">% Note: 1. A is weighted by the sigma.  This can be removed if A would saved earier.</span>
0840 <span class="comment">%       2. Outliers are removed from A, U, S, and V</span>
0841 <span class="keyword">if</span> ~isempty(LocoFlags.SVDDataFileName) &amp;&amp; ischar(LocoFlags.SVDDataFileName)
0842     save(LocoFlags.SVDDataFileName, <span class="string">'A'</span>,<span class="string">'U'</span>,<span class="string">'S'</span>,<span class="string">'V'</span>);
0843 <span class="keyword">end</span>
0844 
0845 
0846 <span class="comment">% Weight the model error to be fit</span>
0847 y = (Mmeas - Mmodel) ./ Mstd;
0848 
0849 
0850 <span class="comment">%%%%%%%%%%%%%%%%%</span>
0851 <span class="comment">% Cost Function %</span>
0852 <span class="comment">%%%%%%%%%%%%%%%%%</span>
0853 <span class="keyword">if</span> isfield(FitParameters, <span class="string">'Weight'</span>)
0854     <span class="comment">% Add the extra parameter weights to y</span>
0855     y(end + (1:NumWeight)) = 0;
0856 <span class="keyword">end</span>
0857 
0858 
0859 <span class="comment">% Single precision conversion</span>
0860 <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
0861     y = single(y);
0862 <span class="keyword">end</span>
0863 
0864 
0865 <span class="comment">% Singular value selection</span>
0866 ChiSquareVector = [];
0867 <span class="keyword">if</span> isempty(SVmethod)
0868     <span class="comment">% Interactively select singular value</span>
0869     SVDquestion = <span class="string">'Select Again'</span>;
0870     <span class="keyword">while</span> strcmp(SVDquestion,<span class="string">'Select Again'</span>)
0871         h1 = figure;
0872         set(h1,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>, [.05 .4 .45 .45]);
0873         subplot(2,1,1);
0874         semilogy(diag(S),<span class="string">'-b'</span>); hold on;
0875         xlabel(<span class="string">'Singular Value Number'</span>);
0876         ylabel(<span class="string">'Magnitude'</span>);
0877         axis([1 length(diag(S)) min(diag(S)) max(diag(S))]);
0878         
0879         subplot(2,1,2);
0880         semilogy(diag(S)/max(diag(S)),<span class="string">'-b'</span>); hold on;
0881         xlabel(<span class="string">'Singular Value Number'</span>);
0882         ylabel(<span class="string">'Magnitude / Max(SV)'</span>);
0883         a = axis;
0884         axis([1 length(diag(S)) a(3) a(4)]);
0885         
0886         <span class="keyword">if</span> ~exist(<span class="string">'SVDquestion2'</span>)   <span class="comment">% Only ask once</span>
0887             SVDquestion2 = questdlg(<span class="string">'Do you want to compute chi-square as a function of S-values (Note: this can be quite time consuming)?'</span>,<span class="string">'LOCO'</span>,<span class="string">'Yes'</span>,<span class="string">'No'</span>,<span class="string">'No'</span>);
0888             <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>) 
0889                 <span class="comment">% Compute Chi-square as a function of S-values</span>
0890                 fprintf(<span class="string">'   Computing chi-square for as a function of S-value ... '</span>); tic
0891                 
0892                 warning off;
0893                 <span class="keyword">for</span> i = 1:length(diag(S))
0894                     lastwarn(<span class="string">''</span>);
0895                     Amod = U(:,1:i) * S(1:i,1:i); 
0896                     b = Amod \ y;                <span class="comment">% Parameter fit</span>
0897                     b = V(:,1:i) * b;
0898                     Mfit = Mstd .* (A*b);        <span class="comment">% Response matrix change for the parameter change</span>
0899                     Mmodelnew = Mmodel + Mfit;   <span class="comment">% New model response matrix</span>
0900                     ChiSquareVector(i) = sum(((Mmeas - Mmodelnew) ./ Mstd) .^ 2) / length(Mstd);
0901                     <span class="keyword">if</span> ~isempty(lastwarn)
0902                         fprintf(<span class="string">'\n   S-value number %d warning: %s'</span>, i, lastwarn);
0903                     <span class="keyword">else</span>
0904                         LastGoodSvalue = i;
0905                     <span class="keyword">end</span>
0906                 <span class="keyword">end</span>
0907                 warning on;
0908                 fprintf(<span class="string">'\n   %f seconds to compute chi-square for as a function of S-value. \n'</span>,toc);
0909                 
0910             <span class="keyword">else</span>
0911                 LastGoodSvalue = length(diag(S));  <span class="comment">% All S-values</span>
0912             <span class="keyword">end</span>
0913         <span class="keyword">end</span>
0914         
0915         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>) 
0916             h2 = figure;
0917             set(h2,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>, [.51 .4 .45 .45]);
0918             semilogy(1:length(diag(S)),ChiSquareVector,<span class="string">'-b'</span>);
0919             xlabel(<span class="string">'Singular Value Number'</span>);
0920             ylabel(<span class="string">'\fontsize{10}\chi^{2} _{/ D.O.F}'</span>);
0921             <span class="comment">%axis tight;</span>
0922             a = axis;
0923             axis([1 length(diag(S)) a(3) a(4)]);
0924         <span class="keyword">end</span>
0925         
0926         def={sprintf(<span class="string">'[%d:%d]'</span>,1,LastGoodSvalue)};
0927         answer=inputdlg({<span class="string">'Which singular values:'</span>},<span class="string">'LOCO'</span>,1,def);
0928         <span class="keyword">if</span> isempty(answer)
0929             close(h1);
0930             <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>); close(h2); <span class="keyword">end</span>
0931             error(<span class="string">'Loco stopped at the users request.'</span>);
0932         <span class="keyword">end</span>
0933         
0934         Ivec = str2num(answer{1});
0935         figure(h1);
0936         subplot(2,1,1);
0937         hold on; 
0938         semilogy(Ivec, diag(S(Ivec,Ivec)),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2); 
0939         
0940         SValues = diag(S);
0941         x=1:length(SValues);
0942         x(Ivec)=[];
0943         SValues(Ivec)=[];
0944         semilogy(x, SValues,<span class="string">'xr'</span>,<span class="string">'MarkerSize'</span>,4); 
0945         hold off
0946         
0947         subplot(2,1,2);
0948         hold on; 
0949         semilogy(Ivec, diag(S(Ivec,Ivec))/max(diag(S)),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
0950         semilogy(x, SValues/max(diag(S)),<span class="string">'xr'</span>,<span class="string">'MarkerSize'</span>,4); 
0951         hold off
0952         
0953         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>) 
0954             figure(h2);
0955             hold on; 
0956             semilogy(Ivec,ChiSquareVector(Ivec),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2); 
0957             hold off;
0958         <span class="keyword">end</span>
0959         
0960         SVDquestion = questdlg(<span class="string">'Do you want to continue?'</span>,<span class="string">'LOCO'</span>,<span class="string">'Continue'</span>,<span class="string">'Select Again'</span>,<span class="string">'Select Again'</span>);
0961                     
0962         <span class="keyword">switch</span> SVDquestion
0963         <span class="keyword">case</span> <span class="string">'Continue'</span>, 
0964             SVmethod = Ivec;
0965         <span class="keyword">end</span>
0966         close(h1);
0967         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
0968             close(h2);
0969         <span class="keyword">end</span>
0970     <span class="keyword">end</span>   
0971     
0972 <span class="keyword">elseif</span> strcmpi((SVmethod),<span class="string">'rank'</span>)
0973     <span class="comment">% Base on  rank deficient warning</span>
0974     <span class="comment">% Compute Chi-square as a function of S-values</span>
0975     fprintf(<span class="string">'   Computing chi-square as a function of S-value ... '</span>); tic
0976     
0977     LastGoodSvalue = 0;
0978     warning off;
0979     
0980     <span class="comment">% Search end:1, looking for a warning (assumes that all larger singular values will not have a warning)</span>
0981     ChiSquareVector = NaN * ones(length(diag(S)),1);
0982     <span class="keyword">for</span> i = length(diag(S)):-1:1
0983         lastwarn(<span class="string">''</span>);
0984         Amod = U(:,1:i) * S(1:i,1:i); 
0985         b = Amod \ y;                <span class="comment">% Parameter fit</span>
0986         b = V(:,1:i) * b;
0987         <span class="comment">%b = V(:,1:i) * ((U(:,1:i) * S(1:i,1:i)) \ y);</span>
0988 
0989         Mfit = Mstd .* (A*b);        <span class="comment">% Response matrix change for the parameter change</span>
0990         Mmodelnew = Mmodel + Mfit;   <span class="comment">% New model response matrix</span>
0991         ChiSquareVector(i) = sum(((Mmeas - Mmodelnew) ./ Mstd) .^ 2) / length(Mstd);
0992         
0993         <span class="keyword">if</span> isempty(lastwarn)
0994             <span class="comment">% If Amod \ y is OK, check that inv(Amod'*Amod) for the variance calculation</span>
0995             <span class="comment">%fprintf('%d removed for inv() \n',i);</span>
0996             bvar = V(:,1:i)*inv(Amod'*Amod)*V(:,1:i)';
0997         <span class="keyword">end</span>
0998         <span class="keyword">if</span> isempty(lastwarn)
0999             LastGoodSvalue = i;
1000             <span class="keyword">break</span>;     <span class="comment">% Once you get a good one assume that the rest are good</span>
1001         <span class="keyword">else</span>
1002             fprintf(<span class="string">'\n   S-value number %d warning: %s'</span>, i, lastwarn);
1003         <span class="keyword">end</span>
1004     <span class="keyword">end</span>
1005     
1006     warning on;
1007     <span class="keyword">if</span> LastGoodSvalue == 1
1008         error(<span class="string">'Rank method for adjusting singular values failed.  Make sure the response matrix is good.'</span>);
1009     <span class="keyword">end</span>
1010 
1011     Ivec = 1:LastGoodSvalue;
1012     fprintf(<span class="string">'\n   %f seconds to compute chi-square as a function of S-value (rank method). \n'</span>,toc);
1013        
1014 <span class="keyword">elseif</span> length(SVmethod) &gt; 1
1015     Ivec = SVmethod;
1016 
1017     
1018     <span class="comment">% % Cost function</span>
1019     <span class="comment">% Ivec = 1:size(A,2)-8;</span>
1020 
1021     
1022     <span class="keyword">if</span> max(Ivec) &gt; length(diag(S))
1023         error(<span class="string">'The number of singular values requested is greater than the total number.'</span>);
1024     <span class="keyword">end</span>
1025 <span class="keyword">else</span>   
1026     <span class="comment">% Base on a threshold of min/max singular value</span>
1027     Ivec = find(diag(S) &gt; max(diag(S))*SVmethod);
1028 <span class="keyword">end</span>
1029 
1030 
1031 <span class="comment">% SVD info</span>
1032 fprintf(<span class="string">'   %d total singular values, %d used in fit, %d removed. \n'</span>, length(diag(S)), length(Ivec), length(diag(S))-length(Ivec));
1033 
1034 
1035 <span class="comment">% Parameter fit</span>
1036 <span class="comment">% A = U*S*V'</span>
1037 <span class="comment">% Remove the E-vectors from the least squares minimization</span>
1038 <span class="comment">% Project on to the modified A matrix, Amod, instead of A</span>
1039 <span class="comment">% Least squares solution to y = Amod * b + e</span>
1040 <span class="comment">% Amod = U(:,Ivec) * S(Ivec,Ivec) = A * V(:,Ivec)</span>
1041 <span class="comment">% U'*U=I and V*V'=I</span>
1042 <span class="comment">% b = Amod \ y is equivalent to b = inv(Amod'*Amod) * Amod' * y</span>
1043 <span class="comment">% b = A \ y;</span>
1044 
1045 fprintf(<span class="string">'   Computing the least square minimization ... '</span>); tic
1046 b = (U(:,Ivec)') * y;
1047 b = diag(diag(S(Ivec,Ivec)).^(-1)) * b;
1048 
1049 <span class="comment">% b at this point is the projection onto the columns of A*V(:,Ivec)</span>
1050 <span class="comment">% Convert the vector b back to coefficents of A</span>
1051 b = V(:,Ivec) * b;
1052 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
1053 
1054 
1055 <span class="comment">% Variance of the parameters</span>
1056 <span class="comment">% Note: the inv(Amod'*Amod) has zero covariance terms</span>
1057 <span class="keyword">if</span> strcmpi(LocoFlags.CalculateSigma, <span class="string">'Yes'</span>)
1058     <span class="comment">% Compute the covariance matrix</span>
1059     <span class="comment">% Only the variance terms are used, the covariance terms are probably interesting</span>
1060     <span class="comment">% and can be output to a file for further analysis.</span>
1061     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>) &amp;&amp; ~(LocoFlags.HorizontalDispersionWeight == 1 &amp;&amp; LocoFlags.VerticalDispersionWeight == 1)
1062         <span class="comment">% Dispersion weight need to be removed:  T E{uu'} T' not an identity matrix</span>
1063         fprintf(<span class="string">'   Computing the fit parameter covariance.  Since the disperson weights are not 1,\n'</span>); tic
1064         fprintf(<span class="string">'   the covariance matrix calculation is more involved.  ... '</span>);
1065         <span class="keyword">for</span> i = 1:NHCM
1066             U(end-NBPM+i,:) = LocoFlags.HorizontalDispersionWeight * U(end-NBPM+i,:);
1067         <span class="keyword">end</span>
1068         <span class="keyword">for</span> i = 1:NVCM
1069             U(end-NVCM+i,:) = LocoFlags.VerticalDispersionWeight * U(end-NVCM+i,:);
1070         <span class="keyword">end</span>
1071 
1072         CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1)) * U(:,Ivec)' * U(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1)) * V(:,Ivec)';
1073         fprintf(<span class="string">'%f seconds. \n'</span>,toc);
1074 
1075     <span class="keyword">else</span>
1076 
1077         CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1));
1078         CovFit = CovFit * CovFit';
1079 
1080         <span class="comment">% same as (C. Steier)</span>
1081         <span class="comment">%CovFit = diag(diag(S(Ivec,Ivec)).^(-2));</span>
1082         <span class="comment">%CovFit = V(:,Ivec) * CovFit * V(:,Ivec)';   % Convert back to coefficents of A</span>
1083         <span class="comment">%b_std = sqrt(diag(CovFit));</span>
1084 
1085     <span class="keyword">end</span>
1086 
1087 
1088     <span class="comment">% Remove the normalization factors (Column weights) from the covariance matrix</span>
1089     <span class="keyword">if</span> strcmpi(NormalizeFlag,<span class="string">'yes'</span>)
1090         <span class="keyword">if</span> NormalizationByRMSFlag
1091             <span class="comment">% Entire A matrix</span>
1092             NormFactor =  abs(NormalizationFact(:));
1093 
1094             <span class="comment">% RF will double normalization</span>
1095             <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
1096                 NormFactor(end-length(LocoParams)) = NormFactor(end-length(LocoParams)) * abs(NormalizationFactRF);
1097             <span class="keyword">end</span>
1098         <span class="keyword">else</span>
1099             NormFactor = ones(NBPMfit, 1);    <span class="comment">% BPMs</span>
1100             NormFactor = [NormFactor; abs(NormalizationFactCM)];    <span class="comment">% CMs</span>
1101             <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
1102                 NormFactor = [NormFactor; ones(NHCM,1)*abs(NormalizationFactHCMEnergy)];    <span class="comment">% HCM Energy Shift</span>
1103             <span class="keyword">end</span>
1104             <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
1105                 NormFactor = [NormFactor; ones(NVCM,1)*abs(NormalizationFactVCMEnergy)];    <span class="comment">% VCM Energy Shift</span>
1106             <span class="keyword">end</span>
1107             <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
1108                 NormFactor = [NormFactor; abs(NormalizationFactRF)];    <span class="comment">% RF</span>
1109             <span class="keyword">end</span>
1110             <span class="keyword">if</span> ~isempty(LocoParams)
1111                 NormFactor = [NormFactor; abs(NormalizationFact)];    <span class="comment">% Parameter fits</span>
1112             <span class="keyword">end</span>
1113         <span class="keyword">end</span>
1114 
1115         CovFit = CovFit * diag(NormFactor.^-1);
1116         CovFit = diag(NormFactor.^-1) * CovFit;
1117     <span class="keyword">end</span>
1118 
1119     b_std = sqrt(diag(CovFit));
1120     
1121 
1122     <span class="comment">% Add the full covariance term to the data save (if requested by the user)</span>
1123     <span class="keyword">if</span> ~isempty(LocoFlags.SVDDataFileName) &amp;&amp; ischar(LocoFlags.SVDDataFileName)
1124         save(LocoFlags.SVDDataFileName, <span class="string">'CovFit'</span>, <span class="string">'-append'</span>);
1125     <span class="keyword">end</span>
1126 
1127     clear CovFit
1128 
1129 <span class="keyword">else</span>
1130     b_std = NaN * ones(size(V,1),1);
1131 <span class="keyword">end</span>
1132 
1133 
1134 <span class="comment">% A is not used anymore</span>
1135 clear A
1136 <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
1137 
1138 
1139 <span class="comment">% Remove the weights from A and compute the new model response matrix (w/o outliers)</span>
1140 <span class="comment">%for i = 1:length(Mstd)</span>
1141 <span class="comment">%    Asave(i,:) = Asave(i,:) * Mstd(i);</span>
1142 <span class="comment">%end</span>
1143 <span class="comment">%Mfit   = Asave*b;           % Response matrix change for the parameter change</span>
1144 <span class="comment">%Mmodel = Mmodel + Mfit;     % New model response matrix</span>
1145 <span class="comment">%ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / length(Mstd);  % Outliers removed</span>
1146 <span class="comment">%fprintf('   Chi-square = %f (Computed from Mmodel(old) + A*b)\n', ChiSquare);</span>
1147 
1148 
1149 SValues = diag(S);
1150 b_delta = b;
1151 
1152 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1153 <span class="comment">% End least squares minimization %</span>
1154 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1155 
1156 
1157 
1158 <span class="comment">% Remove the normalization factor</span>
1159 <span class="keyword">if</span> strcmpi(FitParameters.FitRFFrequency, <span class="string">'yes'</span>)
1160     b_delta(end-length(LocoParams):end-length(LocoParams)) = b_delta(end-length(LocoParams):end-length(LocoParams)) / NormalizationFactRF;
1161     <span class="comment">%b_std(  end-length(LocoParams):end-length(LocoParams)) = b_std(  end-length(LocoParams):end-length(LocoParams)) / abs(NormalizationFactRF);</span>
1162 <span class="keyword">end</span>
1163 <span class="keyword">if</span> strcmpi(NormalizeFlag, <span class="string">'yes'</span>)
1164     <span class="keyword">if</span> NormalizationByRMSFlag        
1165         <span class="comment">% Entire A matrix</span>
1166         b_delta = b_delta ./ NormalizationFact;
1167         <span class="comment">%b_std   = b_std   ./ abs(NormalizationFact);</span>
1168         
1169         <span class="comment">%% Just parameter fits</span>
1170         <span class="comment">%if length(LocoParams) ~= 0</span>
1171         <span class="comment">%    b_delta(end-length(LocoParams)+1:end) = b_delta(end-length(LocoParams)+1:end) ./ NormalizationFact;</span>
1172         <span class="comment">%    b_std(  end-length(LocoParams)+1:end) = b_std(  end-length(LocoParams)+1:end) ./ abs(NormalizationFact);</span>
1173         <span class="comment">%end</span>
1174     <span class="keyword">else</span>
1175         <span class="comment">% CMs</span>
1176         <span class="keyword">if</span> ~isempty(NormalizationFactCM)
1177             b_delta(NBPMfit+1:NBPMfit+length(NormalizationFactCM)) = b_delta(NBPMfit+1:NBPMfit+length(NormalizationFactCM)) ./ NormalizationFactCM;
1178             <span class="comment">%b_std(  NBPMfit+1:NBPMfit+length(NormalizationFactCM)) = b_std(  NBPMfit+1:NBPMfit+length(NormalizationFactCM)) ./ abs(NormalizationFactCM);</span>
1179         <span class="keyword">end</span>
1180         <span class="keyword">if</span> strcmpi(CMData.FitHCMEnergyShift, <span class="string">'yes'</span>)
1181             NN = NBPMfit + length(NormalizationFactCM);
1182             b_delta(NN+1:NN+NHCM) = b_delta(NN+1:NN+NHCM) / NormalizationFactHCMEnergy;
1183             <span class="comment">%b_std(NN+1:NN+NHCM)   = b_std(NN+1:NN+NHCM)   / abs(NormalizationFactHCMEnergy);</span>
1184         <span class="keyword">end</span>
1185         <span class="keyword">if</span> strcmpi(CMData.FitVCMEnergyShift, <span class="string">'yes'</span>)
1186             NN = NBPMfit + length(NormalizationFactCM) + NHCM;
1187             b_delta(NN+1:NN+NVCM) = b_delta(NN+1:NN+NVCM) / NormalizationFactVCMEnergy;
1188             <span class="comment">%b_std(NN+1:NN+NVCM)   = b_std(NN+1:NN+NVCM)   / abs(NormalizationFactVCMEnergy);</span>
1189         <span class="keyword">end</span>
1190         
1191         <span class="comment">% Parameter fits</span>
1192         <span class="keyword">if</span> ~isempty(LocoParams)
1193             b_delta(end-length(LocoParams)+1:end) = b_delta(end-length(LocoParams)+1:end) ./ NormalizationFact;
1194             <span class="comment">%b_std(  end-length(LocoParams)+1:end) = b_std(  end-length(LocoParams)+1:end) ./ abs(NormalizationFact);</span>
1195         <span class="keyword">end</span>
1196     <span class="keyword">end</span>
1197 <span class="keyword">end</span>
1198 
1199 b_new = b_old + b_delta;
1200 
1201 NumberOfFitParameters = length(b_new);
1202 
1203 <span class="comment">% Separate corrector gains from the rest of the parameters</span>
1204 <span class="comment">%fprintf('   Total number of parameters fit = %d\n', length(b_new));</span>
1205 
1206 <span class="comment">% Horizontal BPM gains</span>
1207 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1208     BPMData.HBPMGain(BPMData.HBPMGoodDataIndex) = b_new(1:NHBPM);
1209     b_new(1:NHBPM) = [];
1210     
1211     BPMData.HBPMGainSTD(BPMData.HBPMGoodDataIndex) = b_std(1:NHBPM);
1212     b_std(1:NHBPM) = [];
1213 <span class="keyword">end</span>
1214 
1215 <span class="comment">% Horizontal BPM coupling</span>
1216 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1217     BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex) = b_new(1:NHBPM);
1218     b_new(1:NHBPM) = [];
1219 
1220     BPMData.HBPMCouplingSTD(BPMData.HBPMGoodDataIndex) = b_std(1:NHBPM);
1221     b_std(1:NHBPM) = [];
1222 <span class="keyword">end</span>
1223 
1224 <span class="comment">% Vertical BPM coupling</span>
1225 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1226     BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex) = b_new(1:NVBPM);
1227     b_new(1:NVBPM) = [];
1228 
1229     BPMData.VBPMCouplingSTD(BPMData.VBPMGoodDataIndex) = b_std(1:NVBPM);
1230     b_std(1:NVBPM) = [];
1231 <span class="keyword">end</span>
1232 
1233 <span class="comment">% Vertical BPM gains</span>
1234 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1235     BPMData.VBPMGain(BPMData.VBPMGoodDataIndex) = b_new(1:NVBPM);
1236     b_new(1:NVBPM) = [];
1237 
1238     BPMData.VBPMGainSTD(BPMData.VBPMGoodDataIndex) = b_std(1:NVBPM);
1239     b_std(1:NVBPM) = [];
1240 <span class="keyword">end</span>
1241 
1242 <span class="comment">% Corrector magnet gains</span>
1243 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1244     CMData.HCMKicks(CMData.HCMGoodDataIndex) = b_new(1:NHCM);
1245     b_new(1:NHCM) = [];
1246 
1247     CMData.HCMKicksSTD(CMData.HCMGoodDataIndex) = b_std(1:NHCM);
1248     b_std(1:NHCM) = [];
1249 <span class="keyword">end</span>
1250 
1251 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1252     CMData.VCMKicks(CMData.VCMGoodDataIndex) = b_new(1:NVCM);
1253     b_new(1:NVCM) = [];
1254 
1255     CMData.VCMKicksSTD(CMData.VCMGoodDataIndex) = b_std(1:NVCM);    
1256     b_std(1:NVCM) = [];
1257 <span class="keyword">end</span>
1258 
1259 <span class="comment">% Corrector magnet coupling</span>
1260 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)    
1261     CMData.HCMCoupling(CMData.HCMGoodDataIndex) = b_new(1:NHCM);
1262     b_new(1:NHCM) = [];
1263 
1264     CMData.HCMCouplingSTD(CMData.HCMGoodDataIndex) = b_std(1:NHCM);
1265     b_std(1:NHCM) = [];
1266 <span class="keyword">end</span>
1267 
1268 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)    
1269     CMData.VCMCoupling(CMData.VCMGoodDataIndex) = b_new(1:NVCM);
1270     b_new(1:NVCM) = [];
1271 
1272     CMData.VCMCouplingSTD(CMData.VCMGoodDataIndex) = b_std(1:NVCM);    
1273     b_std(1:NVCM) = [];
1274 <span class="keyword">end</span>
1275 
1276 <span class="comment">% Corrector magnet energy shifts</span>
1277 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
1278     CMData.HCMEnergyShift(CMData.HCMGoodDataIndex) = b_new(1:NHCM);
1279     b_new(1:NHCM) = [];
1280     
1281     CMData.HCMEnergyShiftSTD(CMData.HCMGoodDataIndex) = b_std(1:NHCM);
1282     b_std(1:NHCM) = [];
1283 <span class="keyword">end</span>
1284 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
1285     CMData.VCMEnergyShift(CMData.VCMGoodDataIndex) = b_new(1:NVCM);
1286     b_new(1:NVCM) = [];
1287     
1288     CMData.VCMEnergyShiftSTD(CMData.VCMGoodDataIndex) = b_std(1:NVCM);
1289     b_std(1:NVCM) = [];
1290 <span class="keyword">end</span>
1291 
1292 <span class="comment">% RF Frequency parameter fit</span>
1293 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
1294     FitParameters.DeltaRF = b_new(1);
1295     b_new(1) = [];
1296     
1297     FitParameters.DeltaRFSTD = b_std(1);
1298     b_std(1) = [];
1299 <span class="keyword">end</span>
1300 
1301 
1302 <span class="comment">% The rest of the parameter fits</span>
1303 LocoValues    = b_new;
1304 LocoValuesSTD = b_std;
1305 
1306 
1307 <span class="comment">% Change RINGData for the values in LocoParams</span>
1308 <span class="keyword">for</span> i = 1:length(LocoParams)
1309     RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, LocoParams{i}, LocoValues(i));
1310 <span class="keyword">end</span>
1311 
1312 
1313 <span class="comment">% Compute the new model response matrix with dispersion for saving</span>
1314 fprintf(<span class="string">'   Computing final response matrix (after fit) (%s, %s) ... '</span>, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
1315 CMDataRM.HCMKicks    = CMData.HCMKicks(CMData.HCMGoodDataIndex);
1316 CMDataRM.VCMKicks    = CMData.VCMKicks(CMData.VCMGoodDataIndex);
1317 CMDataRM.HCMCoupling = CMData.HCMCoupling(CMData.HCMGoodDataIndex);
1318 CMDataRM.VCMCoupling = CMData.VCMCoupling(CMData.VCMGoodDataIndex);
1319 warning off;
1320 lastwarn(<span class="string">''</span>);
1321 
1322 <span class="keyword">if</span> isempty(FitParameters.DeltaRF)
1323     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
1324 <span class="keyword">else</span>
1325     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
1326 <span class="keyword">end</span>
1327 warning on;
1328 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
1329 <span class="keyword">if</span> ~isempty(lastwarn)
1330     fprintf(<span class="string">'\n   Warning computing the final response matrix:\n         %s\n'</span>, lastwarn);
1331     fprintf(  <span class="string">'   Check the final values of the fits to make sure they are in a reasonable range for\n'</span>);
1332     fprintf(  <span class="string">'   this accelerator.  Check the input data and/or reduce the number of singular values.\n\n'</span>);
1333 <span class="keyword">end</span>
1334 
1335 
1336 <span class="comment">% Rotate Mmodel and remove BPMs not in the measured response matrix</span>
1337 C11 = ones(length(BPMData.BPMIndex),1);
1338 C11(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMGain(BPMData.HBPMGoodDataIndex);
1339 
1340 C12 = zeros(length(BPMData.BPMIndex),1);
1341 C12(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex);
1342 
1343 C21 = zeros(length(BPMData.BPMIndex),1);
1344 C21(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex);
1345 
1346 C22 = ones(length(BPMData.BPMIndex),1);
1347 C22(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMGain(BPMData.VBPMGoodDataIndex);
1348 
1349 C = [diag(C11) diag(C12)
1350      diag(C21) diag(C22)];
1351 clear C11 C12 C21 C22  
1352 
1353 Mmodel = C * Mmodel;
1354 Mmodel = Mmodel(BPMIndexShort, :); 
1355 
1356 
1357 <span class="comment">% Put the model and dispersion in the proper structures to output</span>
1358 LocoModel = struct(<span class="string">'M'</span>,[], <span class="string">'OutlierIndex'</span>,[], <span class="string">'Eta'</span>,[], <span class="string">'EtaOutlierIndex'</span>,[], <span class="string">'SValues'</span>,[], <span class="string">'SValuesIndex'</span>,[], <span class="string">'ChiSquare'</span>,[]);
1359 <span class="keyword">if</span> isempty(FitParameters.DeltaRF)
1360     LocoModel.M   = Mmodel;
1361     LocoModel.Eta = [];
1362 <span class="keyword">else</span>
1363     LocoModel.M   = Mmodel(:,1:end-1);
1364     LocoModel.Eta = Mmodel(:,end);
1365 <span class="keyword">end</span>
1366 LocoModel.SValues = SValues;
1367 LocoModel.SValuesIndex = Ivec;
1368 
1369 
1370 <span class="comment">% Outliers must reference the coupled model since that is how the model is stored</span>
1371 iOutliersOld = iOutliers;
1372 <span class="keyword">if</span> strcmpi((CouplingFlag),<span class="string">'no'</span>)    
1373     tmp = zeros(size(Mmodel(:)));
1374     tmp(iNoCoupling(iOutliers)) = 1;
1375     iOutliers = find(tmp==1);
1376     clear tmp
1377 <span class="keyword">end</span>
1378 
1379 
1380 <span class="comment">% Separate Mmodel outliers from Eta outliers</span>
1381 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1382     i = find(iOutliers &lt;= (NHBPM+NVBPM)*(NHCM+NVCM));
1383     LocoModel.OutlierIndex = iOutliers(i);
1384     i = find(iOutliers &gt; (NHBPM+NVBPM)*(NHCM+NVCM));
1385     LocoModel.EtaOutlierIndex = iOutliers(i) - ((NHBPM+NVBPM)*(NHCM+NVCM));
1386 <span class="keyword">else</span>
1387     LocoModel.OutlierIndex = iOutliers;
1388     LocoModel.EtaOutlierIndex = [];
1389 <span class="keyword">end</span>
1390 
1391 <span class="comment">% Compute chi-squared based on new model</span>
1392 Mmeas = LocoMeasData.M;
1393 Mmeas = Mmeas([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]); 
1394 
1395 Mstd = LocoMeasData.BPMSTD * ones(1,size(LocoMeasData.M,2));
1396 Mstd = Mstd ([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]); 
1397 
1398 Xstd = LocoMeasData.BPMSTD(BPMData.HBPMGoodDataIndex);
1399 Ystd = LocoMeasData.BPMSTD(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
1400 
1401 
1402 <span class="comment">% When using the fixed momentum response matrix calculator, the merit function becomes:</span>
1403 <span class="comment">%              Merit = Mmeas_ij - Mmod_ij - Dp/p_j * eta_i</span>
1404 <span class="comment">%              where eta_i is the measured eta (not the model eta)</span>
1405 <span class="comment">% This is done by changing Mmodel to (Mmodel_ij + Dp/p_j * eta_i)</span>
1406 <span class="comment">%if strcmpi((CMData.FitHCMEnergyShift),'yes') | strcmpi((CMData.FitVCMEnergyShift),'yes')</span>
1407 <span class="keyword">if</span> strcmpi((LocoFlags.ClosedOrbitType), <span class="string">'fixedmomentum'</span>)
1408     HCMEnergyShift = CMData.HCMEnergyShift(CMData.HCMGoodDataIndex);
1409     VCMEnergyShift = CMData.VCMEnergyShift(CMData.VCMGoodDataIndex);
1410     
1411     <span class="keyword">if</span> ~exist(<span class="string">'AlphaMCF'</span>)
1412         AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
1413         EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
1414         EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
1415     <span class="keyword">end</span>
1416 
1417     <span class="keyword">for</span> i = 1:length(HCMEnergyShift)
1418         Mmodel(:,i) = Mmodel(:,i) + HCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
1419     <span class="keyword">end</span>
1420     
1421     <span class="keyword">for</span> i = 1:length(VCMEnergyShift)
1422         Mmodel(:,NHCM+i) = Mmodel(:,NHCM+i) + VCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
1423     <span class="keyword">end</span>
1424 <span class="keyword">end</span>
1425 
1426 Mstd  = Mstd(:);
1427 Mmeas = Mmeas(:);
1428 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)  
1429     EtaX = LocoMeasData.Eta(BPMData.HBPMGoodDataIndex);
1430     EtaY = LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
1431     
1432     Mstd  = [Mstd;  [Xstd; Ystd]];
1433     Mmeas = [Mmeas; [EtaX; EtaY]];
1434 <span class="keyword">else</span>
1435     <span class="keyword">if</span> ~isempty(FitParameters.DeltaRF)
1436         Mmodel = Mmodel(:,1:end-1);
1437     <span class="keyword">end</span>
1438 <span class="keyword">end</span>
1439 Mmodel = Mmodel(:);
1440 
1441 <span class="comment">% Remove coupling rows</span>
1442 <span class="keyword">if</span> strcmpi((CouplingFlag),<span class="string">'no'</span>)
1443     Mmodel = Mmodel(iNoCoupling,:); 
1444     Mmeas = Mmeas(iNoCoupling,:); 
1445     Mstd = Mstd(iNoCoupling,:); 
1446 <span class="keyword">end</span>
1447 
1448 Mmeas(iOutliersOld) = []; 
1449 Mmodel(iOutliersOld) = []; 
1450 Mstd(iOutliersOld) = [];
1451 <span class="comment">%ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / length(Mstd);</span>
1452 ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / (length(Mstd)-NumberOfFitParameters);   <span class="comment">% mean e'*e = sigma*(n-k)</span>
1453 fprintf(<span class="string">'   Chi-square/D.O.F. = %f (N=%d, K=%d) (computed from final response matrix)\n\n'</span>, ChiSquare, length(Mstd), NumberOfFitParameters);
1454 LocoModel.ChiSquare = ChiSquare;
1455 
1456 
1457 <span class="comment">% Unit conversions (back to LOCO units)</span>
1458 CMData.HCMKicks = 1000*CMData.HCMKicks;        <span class="comment">% radian to milliradians</span>
1459 CMData.VCMKicks = 1000*CMData.VCMKicks;        <span class="comment">% radian to milliradians</span>
1460 CMData.HCMKicksSTD = 1000*CMData.HCMKicksSTD;  <span class="comment">% radian to milliradians</span>
1461 CMData.VCMKicksSTD = 1000*CMData.VCMKicksSTD;  <span class="comment">% radian to milliradians</span>
1462 LocoModel.M   = 1000*LocoModel.M;              <span class="comment">% meters to millimeters</span>
1463 LocoModel.Eta = 1000*LocoModel.Eta;            <span class="comment">% meters to millimeters</span>
1464 
1465 
1466 <span class="comment">%FitParameters.Params = LocoParams;</span>
1467 FitParameters.Values = LocoValues;
1468 FitParameters.Deltas = LocoDeltas;
1469 FitParameters.ValuesSTD = LocoValuesSTD;
1470 
1471</pre></div>
<hr><address>Generated on Mon 21-May-2007 15:32:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>